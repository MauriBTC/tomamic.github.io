<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Logica matematica</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="theme/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/repr/logical-problem.png"></figure>
  <hgroup>
    <h2>Introduzione all'informatica</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Algebra di Boole</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Algebra di Boole</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/hist/george-boole.jpg">
        <figcaption>George Boole, 1815-1864</figcaption>
      </figure><ul>
<li>L’algebra di Boole è un formalismo che opera su variabili (dette <em>variabili booleane</em>)</li>
<li>Le variabili booleane possono assumere due soli valori<ul>
<li><code>Vero</code>: 1</li>
<li><code>Falso</code>: 0</li>
</ul>
</li>
<li>Sulle variabili booleane è possibile definire delle funzioni (dette <em>funzioni booleane</em>)</li>
<li>Anche le funzioni booleane possono assumere solo i due valori <code>vero</code> e <code>falso</code></li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Funzione e tabella di verità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una <em>tabella di verità</em> permette di definire una <em>funzione booleana</em></li>
<li>Valore risultante per ciascuna configurazione dei valori in ingresso</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F<sub>1</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>A volte, <em>specifica incompleta</em>: certe configurazioni di ingressi non possono verificarsi, perciò non è specificato alcun valore</p></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Operatori di base</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Algebra di Boole: basata su un insieme di operatori</li>
<li>Semplici funzioni, specificate con tabelle di verità</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A·B</th>
<th>A+B</th>
<th>A⊕B</th>
<th>A⊼B</th>
<th>A⊽B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>¬A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Espressione booleana</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/hair-logic.svg">
        
      </figure><ul>
<li>Operatori possono essere combinati in espressioni</li>
<li>Altra forma di definizione di funzioni booleane</li>
<li>Es. <code>F<sub>2</sub>(A, B, C) = A·B + C</code></li>
</ul>
<table>
<thead>
<tr>
<th>Operatore</th>
<th>Simbolo</th>
</tr>
</thead>
<tbody>
<tr>
<td>And</td>
<td><code>∧</code> (oppure <code>·</code>)</td>
</tr>
<tr>
<td>Or</td>
<td><code>∨</code> (oppure <code>+</code>)</td>
</tr>
<tr>
<td>Not</td>
<td><code>¬</code> (o sovralinea)</td>
</tr>
<tr>
<td>Xor</td>
<td><code>⊕</code></td>
</tr>
<tr>
<td>Nand</td>
<td><code>⊼</code></td>
</tr>
<tr>
<td>Nor</td>
<td><code>⊽</code></td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Proprietà degli operatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Dimostrazione: si confrontano le due tabelle di verità</li>
</ul>
<table>
<thead>
<tr>
<th>Proprietà</th>
<th>Not</th>
</tr>
</thead>
<tbody>
<tr>
<td>Complemento</td>
<td>¬¬A = A</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Proprietà</th>
<th>And</th>
<th>Or</th>
</tr>
</thead>
<tbody>
<tr>
<td>Commutativa</td>
<td><code>A · B = B · A</code></td>
<td><code>A + B = B + A</code></td>
</tr>
<tr>
<td>Associativa</td>
<td><code>(A·B) · C = A · (B·C)</code></td>
<td><code>(A+B) + C = A + (B+C)</code></td>
</tr>
<tr>
<td>Distributiva</td>
<td><code>A + (B·C) = (A+B) · (A+C)</code></td>
<td><code>A · (B+C) = (A·B) + (A·C)</code></td>
</tr>
<tr>
<td>Idempotenza</td>
<td><code>A · A = A</code></td>
<td><code>A + A = A</code></td>
</tr>
<tr>
<td>Identità</td>
<td><code>A · 1 = A</code></td>
<td><code>A + 0 = A</code></td>
</tr>
<tr>
<td>Del limite</td>
<td><code>A · 0 = 0</code></td>
<td><code>A + 1 = 1</code></td>
</tr>
<tr>
<td>Assorbimento</td>
<td><code>A · (A+B) = A</code></td>
<td><code>A + (A·B) = A</code></td>
</tr>
<tr>
<td>Inverso</td>
<td><code>A · ¬A = 0</code></td>
<td><code>A + ¬A = 1</code></td>
</tr>
<tr>
<td>De Morgan</td>
<td><code>¬(A·B·C…) = ¬A + ¬B + ¬C…</code></td>
<td><code>¬(A+B+C…) = ¬A · ¬B · ¬C…</code></td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>Attenzione a De Morgan: errore comune!</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>De Morgan</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint lang-py" data-lang="py"><code>if x1 == x2 and y1 == y2:
    print("the points are equal")
</code></pre>
<pre class="prettyprint lang-py" data-lang="py"><code>if x1 != x2 or y1 != y2:  # not (x1 == x2 and y1 == y2)
    print("the points are different")
</code></pre>
<ul>
<li>Python permette di confrontare tuple</li>
</ul>
<pre class="prettyprint lang-py" data-lang="py"><code>pt1 = x1, y1
pt2 = x2, y2
if pt1 != pt2:
    print("the points are different")
</code></pre></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Forme canoniche</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Somma di Prodotti (SP)</strong>: si considerano le righe a 1<ul>
<li><code>F<sub>1</sub>(A, B, C) = (¬A·¬B·¬C) + (¬A·B·C) + (A·¬B·C) + (A·B·¬C) + (A·B·C)</code></li>
</ul>
</li>
<li><strong>Prodotto di Somme (PS)</strong>: si considerano le righe a 0, <em>negate</em><ul>
<li><code>F<sub>1</sub>(A, B, C) = (A + B + ¬C) · (A + ¬B + C) · (¬A + B + C)</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F<sub>1</sub></th>
<th>→ Forma canonica...</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Logica delle proposizioni</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Proposizione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Frase dichiarativa (<em>enunciato</em>) di senso compiuto che possa esser riconosciuta come “vera” o “falsa”<ul>
<li><strong>Principio di non contraddizione</strong>: un enunciato non può essere contemporaneamente vero e falso</li>
<li><strong>Principio del terzo escluso</strong>: un enunciato è vero o falso, non esiste una terza possibilità (<em>tertium non datur</em>)</li>
</ul>
</li>
<li>Ad esempio, sono proposizioni:<ul>
<li>“Il cane è un animale” - “2 = 1” - “I triangoli hanno tre lati”</li>
</ul>
</li>
<li>... Mentre non lo sono:<ul>
<li>“Il cane” - “Che ora è?” - “Se 2 = 1” - “Non fumare!” - “Io sono bugiardo” (*)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>(*) Paradosso: non si può stabilire se la frase è vera o falsa</p>
<p>Tarsia @ UniPI: <a href="http://people.dm.unipi.it/tarsia/dida1011/logins05.pdf">http://people.dm.unipi.it/tarsia/dida1011/logins05.pdf</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Connettivi logici</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gli operatori booleani si usano anche con le proposizioni<ul>
<li>“e” (<em>congiunzione</em>, <code>∧</code>)</li>
<li>“o” (<em>disgiunzione</em>, <code>∨</code>)</li>
<li>“non” (<em>negazione</em>, <code>¬</code>)</li>
<li>Valgono le proprietà già viste</li>
</ul>
</li>
<li>In logica, chiamati <em>connettivi</em><ul>
<li>Servono a legare proposizioni in forma più complessa</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Implicazione logica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Connettivo condizionale</strong>: esprime il legame “se” ... “allora”<ul>
<li><code>P</code>: “io penso” (<em>premessa</em>)</li>
<li><code>Q</code>: “io esisto” (<em>conseguenza</em>)</li>
<li><code>P ⇒ Q</code>: “se penso allora esisto”</li>
</ul>
</li>
<li><code>P ⇒ Q</code> si può leggere anche nei seguenti modi:<ul>
<li>Da <code>P</code> segue <code>Q</code></li>
<li><code>P</code> è <em>condizione sufficiente</em> per <code>Q</code> (se <code>P</code> vera, allora <code>Q</code> vera)</li>
<li><code>Q</code> è <em>condizione necessaria</em> per <code>P</code> (se <code>Q</code> falsa, allora <code>P</code> falsa)</li>
</ul>
</li>
<li>Esempi di implicazioni vere:<ul>
<li>“Se 5 è un numero allora Roma è una città”</li>
<li>“Se Parigi è la capitale d'Italia, allora 5 + 5 = 10”</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Verità dell'implicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th><code>P</code></th>
<th><code>Q</code></th>
<th><code>P ⇒ Q</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>F</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
<ul>
<li><code>P ⇒ Q</code> è falsa solo in un caso: <code>P</code> vera e <code>Q</code> falsa<ul>
<li><code>¬(P ⇒ Q) = (P ∧ ¬Q)</code></li>
<li><code>P ⇒ Q = ¬(P ∧ ¬Q) =</code> <em>[De Morgan]</em> <br> <code>¬P ∨ ¬(¬Q) =</code> <em>[Doppia negazione]</em> <br> <code>¬P ∨ Q</code> (implicazione vera quando: <code>P</code> falsa, o <code>Q</code> vera)</li>
</ul>
</li>
<li>L'implicazione <strong>non</strong> soddisfa la proprietà commutativa:<ul>
<li><code>(P ⇒ Q) ≠ (Q ⇒ P)</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Doppia implicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th><code>P</code></th>
<th><code>Q</code></th>
<th><code>P ⇒ Q</code></th>
<th><code>Q ⇒ P</code></th>
<th><code>P ⇔ Q</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
<ul>
<li><code>P ⇔ Q</code>: valgono entrambe le implicazioni, <code>(P⇒Q) ∧ (Q⇒P)</code></li>
<li><code>P ⇔ Q</code> vera quando: <code>P</code> e <code>Q</code> entrambe vere, o entrambe false<ul>
<li>Da proprietà distributiva e proprietà dell'inverso</li>
<li><code>(P⇒Q) ∧ (Q⇒P) =</code> <br> <code>(¬P∨Q) ∧ (¬Q∨P) =</code> <br> <code>(¬P ∧ (¬Q∨P)) ∨ (Q ∧ (¬Q∨P)) =</code> <br> <code>(¬P∧¬Q) ∨ (¬P∧P) ∨ (¬Q∧Q) ∨ (P∧Q) =</code> <br> <code>(P∧Q) ∨ (¬P∧¬Q)</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Deduzione logica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un <em>teorema</em> si riconduce all’implicazione <code>P ⇒ Q</code><ul>
<li><code>P</code> (<em>ipotesi</em>): proposizione che si assume vera</li>
<li><code>Q</code> (<em>tesi</em>): proposizione di cui si vuole dedurre la verità</li>
</ul>
</li>
<li>Processo di <em>deduzione logica</em>, o <em>dimostrazione</em>, deve seguire ben precisi schemi di ragionamento<ul>
<li>Dimostrazione diretta (<em>modus ponens</em>)</li>
<li>Dimostrazione per assurdo (<em>modus tollens</em>)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dimostrazione diretta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><em>Modus ponens</em>: schema di ragionamento</li>
</ul>
<table>
<thead>
<tr>
<th>Premessa</th>
<th>Conseguenza</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(P ⇒ Q)</code> vera <br> <code>P</code> vera</td>
<td><code>Q</code> vera</td>
</tr>
</tbody>
</table>
<ul>
<li>Esempio<ul>
<li>Se c'è sole, Ugo arriva in bici (implicazione, <em>regola d'inferenza</em>)</li>
<li>C'è sole (<em>fatto</em>)</li>
<li>Ugo arriva in bici (<em>deduzione</em>)</li>
</ul>
</li>
<li><strong>Osservazione</strong>: il solo fatto di sapere che <code>P⇒Q</code> è vera non consente di concludere niente su <code>P</code> e <code>Q</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Passaggi intermedi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sono possibili dimostrazioni con più passaggi intermedi</li>
<li>Se vere le implicazioni <code>P⇒R</code>, <code>R⇒Q</code>... <br> e se <code>P</code> vera... <br> allora vera anche <code>Q</code></li>
<li><code>((P⇒R) ∧ (R⇒Q) ∧ P) ⇒ Q</code></li>
<li>Schema di ragionamento</li>
</ul>
<table>
<thead>
<tr>
<th>Premessa</th>
<th>Conseguenza</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(P ⇒ R)</code> vera <br> <code>(R ⇒ Q)</code> vera <br> <code>P</code> vera</td>
<td><code>Q</code> vera</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Implicazione equivalente</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th><code>P</code></th>
<th><code>Q</code></th>
<th><code>P ⇒ Q</code></th>
<th><code>¬Q</code></th>
<th><code>¬P</code></th>
<th><code>¬Q ⇒ ¬P</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
</tr>
</tbody>
</table>
<ul>
<li>Queste due implicazioni sono equivalenti<ul>
<li><code>P ⇒ Q</code></li>
<li><code>¬Q ⇒ ¬P</code></li>
</ul>
</li>
<li>Nelle dimostrazioni, possiamo usare la seconda implicazione al posto della prima</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dimostrazione per assurdo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se è vera l’implicazione <code>(¬Q ⇒ ¬P)</code> ed è vera <code>P</code>, allora è vera anche <code>Q</code></li>
<li><em>Modus tollens</em>: schema di ragionamento</li>
</ul>
<table>
<thead>
<tr>
<th>Premessa</th>
<th>Conseguenza</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(¬Q ⇒ ¬P)</code> vera <br> <code>P</code> vera</td>
<td><code>Q</code> vera</td>
</tr>
</tbody>
</table>
<ul>
<li>Esempio di teorema<ul>
<li><code>P</code>: <code>m·n ≠ 0</code></li>
<li><code>Q</code>: <code>(m ≠ 0) ∧ (n ≠ 0)</code></li>
<li>Dimostrazione per assurdo: <code>¬Q ⇒ ¬P</code></li>
<li>Se <code>(m = 0) ∨ (n = 0)</code>, allora <code>m·n = 0</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Logica dei predicati</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Predicato, o enunciato aperto</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Frase che contiene <em>variabili</em><ul>
<li>La verità della frase dipende dal valore delle variabili</li>
<li>Se variabili sostituite da valori, diventa proposizione</li>
</ul>
</li>
<li>Esempio<ul>
<li><code>P(x)</code>: “x è un numero dispari”</li>
</ul>
</li>
<li>Occorre definire il <em>dominio</em> delle variabili</li>
<li><em>Insieme di verità</em> del predicato<ul>
<li>Valori delle variabili che rendono vero l'enunciato</li>
<li>Sottoinsieme del dominio delle variabili</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Predicati con connettivi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>P(x) ∧ Q(x)</code> -- Vero per gli <code>x</code> che rendono veri entrambi i pred.</li>
<li><code>P(x) ∨ Q(x)</code> -- Vero per gli <code>x</code> che rendono vero almeno un pred.</li>
<li><code>¬P(x)</code> -- Vero per gli <code>x</code> che rendono falso il pred.</li>
<li><code>P(x) ⇒ Q(x)</code> -- Vero per gli <code>x</code> che rendono falso <code>P</code> oppure vero <code>Q</code></li>
<li><code>P(x) ⇔ Q(x)</code> -- Vero per gli <code>x</code> che rendono i pred. entrambi falsi o entrambi veri</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Quantificatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un predicato può essere trasformato in una proposizione in due modi<ul>
<li>Sostituendo la variabili con valori</li>
<li><em>Quantificando</em> le sue variabili</li>
<li>Una variabile legata ad un quantificatore si dice <em>vincolata</em>, altrimenti <em>libera</em></li>
</ul>
</li>
<li>I quantificatori logici sono due<ul>
<li>Quantificatore <strong>universale</strong></li>
<li>Quantificatore <strong>esistenziale</strong></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Quantificatore universale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una data proprietà vale per tutti i valori possibili delle variabili</li>
<li><code>∀x, P(x)</code> -- “Per ogni x, P(x) è vero”</li>
<li>Esempi<ul>
<li><code>∀n ∈ N, n multiplo di 4 ⇒ n pari</code></li>
<li><code>∀x ∈ R ∀y ∈ R, (x + y)<sup>2</sup> = x<sup>2</sup> + 2xy + y<sup>2</sup></code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Quantificatore esistenziale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una data proprietà vale per almeno un valore delle variabili</li>
<li><code>∃x : P(x)</code> -- “Esiste almeno un x tale che P(x) è vero”</li>
<li>Esempi<ul>
<li><code>∃n ∈ N : n pari</code> -- Esiste almeno un numero pari</li>
<li><code>∃x ∈ R : 2x + 1 = 0</code> -- L'equazione ammette almeno una soluzione</li>
</ul>
</li>
<li>Enunciati con <code>∄</code> riformulati con <code>∀</code> e negando il predicato<ul>
<li><code>∄x : x<sup>2</sup> &lt; 0</code></li>
<li><code>∀x, x<sup>2</sup> ≥ 0</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Proprietà dei quantificatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I quantificatori sono sostanzialmente <em>congiunzioni</em> o <em>disgiunzioni</em> allargate a tutti gli elementi di un insieme</li>
<li>Due quantificatori dello stesso tipo <em>possono</em> essere scambiati di posto senza alterare la verità dell’enunciato</li>
<li>Invece, due quantificatori di diverso tipo <em>non possono</em> essere scambiati di posto</li>
<li>I seguenti enunciati sono ben diversi<ul>
<li><code>∀x, ∃y : y ≥ x</code></li>
<li><code>∃y : ∀x, y ≥ x</code></li>
</ul>
</li>
<li><strong>Sillogismi</strong> aristotelici: modus ponens con quantificatori<ul>
<li><em>Premessa maggiore</em>: “Tutti gli uomini sono mortali”</li>
<li><em>Premessa minore</em>: “Socrate è un uomo”</li>
<li><em>Conclusione</em>: “Socrate è mortale”</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Negazione con quantificatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Per negare un enunciato che contiene quantificatori, occorrono due modifiche:<ul>
<li><strong>(1)</strong> Sostituire tutti i <code>∀</code> con <code>∃</code>, e viceversa</li>
<li><strong>(2)</strong> Negare il predicato</li>
</ul>
</li>
<li>Esempi<ul>
<li><code>¬(∀x, P(x)) ⇔ ∃x : ¬P(x)</code></li>
<li><code>¬(∃x : P(x)) ⇔ ∀x, ¬P(x)</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Operazioni tra insiemi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Siano definiti due insiemi: <code>A = {x : P(x)}, B = {x : Q(x)}</code></li>
<li>Unione: <code>A ∪ B = {x : x ∈ A ∨ x ∈ B} = {x : P(x) ∨ Q(x)}</code></li>
<li>Intersezione: <code>A ∩ B = {x : x ∈ A ∧ x ∈ B} = {x : P(x) ∧ Q(x)}</code></li>
<li>Complemento: <code>A' = {x : x ∉ A} = {x : ¬P(x)}</code></li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Proprietà degli insiemi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Siano definiti due insiemi: <code>A = {x : P(x)}, B = {x : Q(x)}</code></li>
</ul>
<table>
<thead>
<tr>
<th>Proprietà</th>
<th>Op. tra insiemi</th>
<th>Op. tra predicati</th>
</tr>
</thead>
<tbody>
<tr>
<td>Commutativa</td>
<td><code>A ∪ B = B ∪ A</code></td>
<td><code>P ∨ Q ⇔ Q ∨ P</code></td>
</tr>
<tr>
<td>Commutativa</td>
<td><code>A ∩ B = B ∩ A</code></td>
<td><code>P ∧ Q ⇔ Q ∧ P</code></td>
</tr>
<tr>
<td>Associativa</td>
<td><code>(A∪B) ∪ C = A ∪ (B∪C)</code></td>
<td><code>(P∨Q) ∨ R ⇔ P ∨ (Q∨R)</code></td>
</tr>
<tr>
<td>Associativa</td>
<td><code>(A∩B) ∩ C = A ∩ (B∩C)</code></td>
<td><code>(P∧Q) ∧ R ⇔ P ∧ (Q∧R)</code></td>
</tr>
<tr>
<td>Distributiva</td>
<td><code>(A∪B) ∩ C = (A∩C) ∪ (B∩C)</code></td>
<td><code>(P∨Q) ∧ R ⇔ (P∧R) ∨ (Q∧R)</code></td>
</tr>
<tr>
<td>Distributiva</td>
<td><code>(A∩B) ∪ C = (A∪C) ∩ (B∪C)</code></td>
<td><code>(P∧Q) ∨ R ⇔ (P∨R) ∧ (Q∨R)</code></td>
</tr>
<tr>
<td>Doppia negazione</td>
<td><code>(B')' = B</code></td>
<td><code>¬(¬P) ⇔ P</code></td>
</tr>
<tr>
<td>De Morgan</td>
<td><code>(A ∪ B)' = A' ∩ B'</code></td>
<td><code>¬(P ∨ Q) ⇔ ¬P ∧ ¬Q</code></td>
</tr>
<tr>
<td>De Morgan</td>
<td><code>(A ∩ B)' = A' ∪ B'</code></td>
<td><code>¬(P ∧ Q) ⇔ ¬P ∨ ¬Q</code></td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Principio di induzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/dominoes.png">
        
      </figure><ul>
<li>Sia <code>P(n)</code> un predicato definito su <code>ℕ</code>, tale che:<ul>
<li><strong>(1)</strong> <code>P(1)</code> è vero</li>
<li><strong>(2)</strong> <code>∀n</code>, supponendo <code>P(n)</code> vero, segue che anche <code>P(n+1)</code> è vero</li>
<li>Allora <code>P(n)</code> risulta vero <code>∀n</code></li>
</ul>
</li>
<li>In una formula:<ul>
<li><code>(P(1) ∧ (∀n, P(n)⇒P(n+1)))</code> <br> <code>⇒ (∀n, P(n))</code></li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Alcuni predicati sono definiti a partire da un dato <code>k</code>, anzichè da 1</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio, formula di Gauss</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Definiamo per comodità <code>G(n) = n·(n+1) / 2</code></li>
<li>Definiamo il predicato <code>P(n)</code> come: <code>1 + 2 + ··· + n = G(n)</code></li>
<li>Dimostriamo <em>per induzione</em> che il predicato è vero <code>∀n</code></li>
<li><strong>(1)</strong> Il predicato per <code>n=1</code> è vero, infatti:<ul>
<li><code>G(1) = 1 · (1+1) / 2 = 1</code></li>
</ul>
</li>
<li><strong>(2)</strong> Supponiamo <code>P(n)</code> vero, ne segue <code>P(n+1)</code> vero, infatti:<ul>
<li>Per la somma fino ad <code>n+1</code>, bisogna aggiungere un termine:</li>
<li><code>n+1 + G(n) = n+1 + n·(n+1)/2 =</code> <br> <code>= (n<sup>2</sup> + 3·n + 2) / 2 = (n+1)·(n+2)/2 = G(n+1)</code></li>
</ul>
</li>
<li>Quindi la formula vale <code>∀n</code></li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="theme/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://sowide.unipr.it/tomamic">sowide.unipr.it/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>