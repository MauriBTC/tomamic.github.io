<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Sistema binario</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="theme/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/repr/binary-fingers.svg"></figure>
  <hgroup>
    <h2>Introduzione all'informatica</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Analogico e digitale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/analog-clock.png"><img src="images/repr/digital-clock.png">
        
      </figure><ul>
<li>Una grandezza (fisica o astratta) può essere rappresentata in due forme<ul>
<li><strong>Analogica</strong>: insieme di valori <strong>continuo</strong> (<em>denso e “senza buchi”</em>)</li>
<li><strong>Digitale</strong> (o numerica): insieme di valori <strong>discreto</strong> (<em>tutti i punti sono isolati</em>)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Approssimazione discreta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Alcune informazioni sono intrinsecamente discrete<ul>
<li>Informazioni “artificiali”, es. un testo scritto</li>
<li>Scala atomica o subatomica …</li>
</ul>
</li>
<li>Molte grandezze fisiche hanno forma continua<ul>
<li>Per loro elaborazione al calcolatore: rappresentazione digitale</li>
<li><em>Approssimazione</em> del valore analogico</li>
<li>Errore dipende dalla precisione della rappresentazione digitale scelta</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Codice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sistema basato su simboli, che permette la rappresentazione dell’informazione</li>
<li><em>Simbolo</em>: elemento atomico</li>
<li><em>Alfabeto</em>: insieme dei simboli possibili (<code>A</code>)</li>
<li><em>Cardinalità</em> del codice: numero di simboli dell’alfabeto</li>
<li><em>Stringa</em>: sequenza di simboli (<code>s ∈ A*</code>)</li>
<li><em>Linguaggio</em>: insieme stringhe ben formate (<code>L ⊆ A*</code>)</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Codice posizionale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/child-fingers.png">
        
      </figure><ul>
<li>Un numero naturale può essere rappresentato con una notazione posizionale</li>
<li><code>N = c<sub>0</sub> · base<sup>0</sup> + c<sub>1</sub> · base<sup>1</sup> + … + c<sub>n</sub> · base<sup>n</sup></code><ul>
<li>Es. <code>587<sub>10</sub> = 7·10<sup>0</sup> + 8·10<sup>1</sup> + 5·10<sup>2</sup></code></li>
</ul>
</li>
<li>Sistemi di numerazione posizionali di uso comune<ul>
<li>Decimale (base 10; c: <code>0-9</code>)</li>
<li>Binario (base 2; c: <code>0-1</code>)</li>
<li>Esadecimale (base 16; c: <code>0-9, A-F</code>)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Codifica dell’informazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Codifica: regole di corrispondenza per passare da un certo codice ad un altro</li>
<li>Corrispondenza biunivoca<ul>
<li>Tra una stringa di un codice</li>
<li>E una stringa di un altro codice</li>
</ul>
</li>
<li>Ad una certa stringa in un alfabeto ricco di simboli, corrisponde una stringa più lunga in un alfabeto più ridotto</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Numeri binari</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Codice binario</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/sum-binary.jpg">
        
      </figure><ul>
<li>Base 2; c: <code>0-1</code></li>
<li>Informazione digitale nei calcolatori rappresentata con una sequenza di 0 e 1<ul>
<li>Sistema ideato da Leibniz, ~1700</li>
<li>Calcolatore progr. Zuse, ~1940</li>
</ul>
</li>
<li>Ogni elemento di una sequenza binaria viene detto <strong>bit</strong></li>
<li>Una sequenza di <em>8 bit</em> viene detta <strong>byte</strong></li>
</ul>
<blockquote></blockquote>
<p><a href="https://www.wikihow.com/Convert-from-Binary-to-Decimal">https://www.wikihow.com/Convert-from-Binary-to-Decimal</a></p>
<p><a href="https://www.wikihow.com/Convert-from-Decimal-to-Binary">https://www.wikihow.com/Convert-from-Decimal-to-Binary</a></p></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Codifica decimale → binaria</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><em>(1)</em> Dividere il numero decimale per 2</li>
<li><em>(2)</em> Il resto è il valore del nuovo bit, a sinistra</li>
<li><em>(3)</em> Il quoziente è il numero con cui continuare <em>(loop)</em></li>
<li>Ossia continuare a dividere per 2 il quoziente, finché non si annulla</li>
<li>Es.: <code>35<sub>10</sub> = 00100011<sub>2</sub></code></li>
</ul>
<table>
<thead>
<tr>
<th>n</th>
<th>n // B</th>
<th>n % B</th>
<th>peso</th>
</tr>
</thead>
<tbody>
<tr>
<td>35</td>
<td>17</td>
<td>1</td>
<td>1 = 2<sup>0</sup></td>
</tr>
<tr>
<td>17</td>
<td>8</td>
<td>1</td>
<td>2 = 2<sup>1</sup></td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>0</td>
<td>4 = 2<sup>2</sup></td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>0</td>
<td>8 = 2<sup>3</sup></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>16 = 2<sup>4</sup></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>32 = 2<sup>5</sup></td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Numeri naturali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/binary-fingers.svg">
        <figcaption>... 819</figcaption>
      </figure><ul>
<li>Rappresentare un numero naturale <code>N</code> in forma binaria</li>
<li>Occorrono <code>K</code> bit, t.c. <code>2<sup>K</sup> &gt; N</code></li>
<li>Es. 4 bit per numeri naturali da 0 a 15</li>
<li>Un calcolatore assegna un numero fisso di bit per diversi tipi di informazione<ul>
<li>Casi di valori non rappresentabili</li>
<li><strong>Overflow</strong>, <strong>underflow</strong></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Esadecimale (Hex)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th>Dec</th>
<th>Bin</th>
<th>Hex</th>
<th>Dec</th>
<th>Bin</th>
<th>Hex</th>
<th>Dec</th>
<th>Bin</th>
<th>Hex</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>00</strong></td>
<td>0000 0000</td>
<td>00</td>
<td><strong>16</strong></td>
<td>0001 0000</td>
<td>10</td>
<td><strong>32</strong></td>
<td>0010 0000</td>
<td>20</td>
</tr>
<tr>
<td><strong>01</strong></td>
<td>0000 0001</td>
<td>01</td>
<td><strong>17</strong></td>
<td>0001 0001</td>
<td>11</td>
<td><strong>33</strong></td>
<td>0010 0001</td>
<td>21</td>
</tr>
<tr>
<td><strong>02</strong></td>
<td>0000 0010</td>
<td>02</td>
<td><strong>18</strong></td>
<td>0001 0010</td>
<td>12</td>
<td><strong>34</strong></td>
<td>0010 0010</td>
<td>22</td>
</tr>
<tr>
<td><strong>03</strong></td>
<td>0000 0011</td>
<td>03</td>
<td><strong>19</strong></td>
<td>0001 0011</td>
<td>13</td>
<td><strong>35</strong></td>
<td>0010 0011</td>
<td>23</td>
</tr>
<tr>
<td><strong>04</strong></td>
<td>0000 0100</td>
<td>04</td>
<td><strong>20</strong></td>
<td>0001 0100</td>
<td>14</td>
<td><strong>36</strong></td>
<td>0010 0100</td>
<td>24</td>
</tr>
<tr>
<td><strong>05</strong></td>
<td>0000 0101</td>
<td>05</td>
<td><strong>21</strong></td>
<td>0001 0101</td>
<td>15</td>
<td><strong>37</strong></td>
<td>0010 0101</td>
<td>25</td>
</tr>
<tr>
<td><strong>06</strong></td>
<td>0000 0110</td>
<td>06</td>
<td><strong>22</strong></td>
<td>0001 0110</td>
<td>16</td>
<td><strong>38</strong></td>
<td>0010 0110</td>
<td>26</td>
</tr>
<tr>
<td><strong>07</strong></td>
<td>0000 0111</td>
<td>07</td>
<td><strong>23</strong></td>
<td>0001 0111</td>
<td>17</td>
<td><strong>39</strong></td>
<td>0010 0111</td>
<td>27</td>
</tr>
<tr>
<td><strong>08</strong></td>
<td>0000 1000</td>
<td>08</td>
<td><strong>24</strong></td>
<td>0001 1000</td>
<td>18</td>
<td><strong>40</strong></td>
<td>0010 1000</td>
<td>28</td>
</tr>
<tr>
<td><strong>09</strong></td>
<td>0000 1001</td>
<td>09</td>
<td><strong>25</strong></td>
<td>0001 1001</td>
<td>19</td>
<td><strong>41</strong></td>
<td>0010 1001</td>
<td>29</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>0000 1010</td>
<td>0A</td>
<td><strong>26</strong></td>
<td>0001 1010</td>
<td>1A</td>
<td><strong>42</strong></td>
<td>0010 1010</td>
<td>2A</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>0000 1011</td>
<td>0B</td>
<td><strong>27</strong></td>
<td>0001 1011</td>
<td>1B</td>
<td><strong>43</strong></td>
<td>0010 1011</td>
<td>2B</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>0000 1100</td>
<td>0C</td>
<td><strong>28</strong></td>
<td>0001 1100</td>
<td>1C</td>
<td><strong>44</strong></td>
<td>0010 1100</td>
<td>2C</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>0000 1101</td>
<td>0D</td>
<td><strong>29</strong></td>
<td>0001 1101</td>
<td>1D</td>
<td><strong>45</strong></td>
<td>0010 1101</td>
<td>2D</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td>0000 1110</td>
<td>0E</td>
<td><strong>30</strong></td>
<td>0001 1110</td>
<td>1E</td>
<td><strong>46</strong></td>
<td>0010 1110</td>
<td>2E</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td>0000 1111</td>
<td>0F</td>
<td><strong>31</strong></td>
<td>0001 1111</td>
<td>1F</td>
<td><strong>47</strong></td>
<td>0010 1111</td>
<td>2F</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Bin ↔ Hex</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/4bits.png">
        
      </figure><p><img alt="" src="images/repr/bin-hex.png" /></p>
<ul>
<li>Ogni gruppo di 4 bit: 16 configurazioni diverse<ul>
<li><em>Disposizioni con ripetizione</em>: <code>2<sup>4</sup> = 16</code></li>
</ul>
</li>
<li>Ciascuna configurazione corrisponde ad uno dei 16 simboli esadecimali</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Somma e sottrazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="" data-lang="Binary"><code>    1   1
0 0 0 1 0 1 1 0 +
0 0 0 1 0 1 0 1 =
-----------------
0 0 1 0 1 0 1 1
</code></pre>
<pre class="" data-lang="Binary"><code>            0 10
0 0 0 0 1 1 1 0 -
0 0 0 0 0 1 0 1 =
-----------------
0 0 0 0 1 0 0 1
</code></pre>
<p>Attenzione a riporto e prestito (in alto)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Moltiplicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="" data-lang="Binary"><code>        1 0 1 1 x
        1 1 0 1 =
        ---------
        1 0 1 1 +
      0 0 0 0
    -------------
      0 1 0 1 1 +
    1 0 1 1
  ---------------
    1 1 0 1 1 1 +
  1 0 1 1
-----------------
1 0 0 0 1 1 1 1
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Divisione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="" data-lang="Binary"><code>1 0 1 1 0 1 : 1 1
0 0          ---------
-----         0 1 1 1 1
1 0 1 -
  1 1
-------
  1 0 1 -
    1 1
  -------
    1 0 0 -
      1 1
    -------
        1 1 -
        1 1
        -----
        0 0
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Numeri interi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/4bits-sign.png">
        
      </figure><ul>
<li>Occorre rappresentare anche i numeri negativi<ul>
<li>Necessario riservare un bit per il segno</li>
<li>Ovvero, si dimezza il massimo modulo ammesso</li>
</ul>
</li>
<li><strong>Modulo e segno</strong><ul>
<li>Il primo bit indica il segno</li>
<li>0 positivo, 1 negativo</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Complemento a due</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/4bits-sign.png">
        
      </figure><ul>
<li>Rappresentazione alternativa, <em>diversa da modulo e segno!</em></li>
<li>Numero negativo, ottenuto dal suo opposto positivo<ul>
<li>Complemento il numero <br> (gli 1 diventano 0 e viceversa)</li>
<li>Sommo 1</li>
</ul>
</li>
<li>Anche così, il primo bit indica il segno<ul>
<li>0 positivo, 1 negativo</li>
</ul>
</li>
<li><em>Attenzione</em>: bisogna conoscere codifica e num bit<ul>
<li>Esempi seguenti: ogni intero con segno memorizzato in un singolo <em>byte</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Es. numero intero</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Avendo <em>un byte</em>, +35 è in binario: <strong><code>0</code></strong><code>0100011</code></li>
<li>Numero –35, in modulo e segno: <strong><code>1</code></strong><code>0100011</code></li>
<li>Numero –35, in complemento a due: <strong><code>1</code></strong><code>1011101</code></li>
</ul>
<pre class="" data-lang="Binary"><code>0 0 1 0 0 0 1 1 ¬
-----------------
1 1 0 1 1 1 0 0 +
              1 =
-----------------
1 1 0 1 1 1 0 1
</code></pre>
<p><code>¬</code>: complemento semplice, bit a bit</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Somma con segno</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sommare 12 e -35 su 8 bit, modulo e segno<ul>
<li>Sottrazione tra 35 e 12</li>
<li>Cambio di segno</li>
</ul>
</li>
<li>Stessa operazione, complemento a due<ul>
<li>Semplice somma: <code>12 + -35 = -23</code></li>
</ul>
</li>
</ul>
<pre class="" data-lang="Binary"><code>0 0 0 0 1 1 0 0 +
1 1 0 1 1 1 0 1 =
-----------------
1 1 1 0 1 0 0 1
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Numeri reali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Insieme continuo, per grandezze analogiche<ul>
<li>Rappresentabili solo in modo approssimato</li>
</ul>
</li>
<li>Parte frazionaria:<ul>
<li><code>F = c<sub>-1</sub> · base<sup>-1</sup> + … + c<sub>-n</sub> · base<sup>-n</sup></code></li>
</ul>
</li>
<li>Due rappresentazioni <em>alternative</em><ul>
<li><strong>Virgola fissa</strong>: segno, parte intera, parte decimale</li>
<li><strong>Virgola mobile</strong>: segno, mantissa, esponente</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Parte frazionaria in binario</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><em>(1)</em> Moltiplicare la parte frazionaria per 2</li>
<li><em>(2)</em> Assegnare la parte intera del risultato come valore del bit <em>(loop)</em></li>
<li>Ossia: continuare a moltiplicare per 2 la parte frazionaria del risultato... <br> finché non si annulla</li>
</ul>
<table>
<thead>
<tr>
<th>fract</th>
<th>fract*B</th>
<th>int</th>
<th>peso</th>
</tr>
</thead>
<tbody>
<tr>
<td>0,375</td>
<td>0,750</td>
<td>0</td>
<td>2<sup>-1</sup></td>
</tr>
<tr>
<td>0,750</td>
<td>1,500</td>
<td>1</td>
<td>2<sup>-2</sup></td>
</tr>
<tr>
<td>0,500</td>
<td>1,000</td>
<td>1</td>
<td>2<sup>-3</sup></td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Virgola fissa</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Numero espresso come: <code>r = (i, f)</code><ul>
<li><strong><code>i</code></strong> è la parte intera, <code>n<sub>1</sub></code> bit</li>
<li><strong><code>f</code></strong> è la parte frazionaria, <code>n<sub>2</sub></code> bit</li>
</ul>
</li>
<li>Precisione costante lungo l’asse reale<ul>
<li>P.es. <code>f</code> di 3 bit, valori consecutivi sempre distanziati di 1/8</li>
<li>Tra ciascun intero e il successivo, possiamo rappresentare 8 valori</li>
</ul>
</li>
</ul>
<p><img alt="" src="images/repr/fixed-point.png" /></p></article>
 
</slide>

<slide class="large-image" >
  
    <hgroup>
      <h2>Virgola mobile</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Numero espresso come: <code>r = ±(1+f)·2<sup>e</sup></code><ul>
<li><strong><code>e</code></strong> è l'esponente intero (o caratteristica), <code>n<sub>1</sub></code> bit</li>
<li><strong><code>f</code></strong> è la parte frazionaria <em>(0 ≤ f &lt; 1)</em>, <code>n<sub>2</sub></code> bit</li>
<li><code>2</code> è la base, <code>1+f</code> è anche detto <em>mantissa</em></li>
</ul>
</li>
<li>Precisione variabile lungo l’asse reale; p.es.:<ul>
<li><code>f ∈ {0, 1/4, 2/4, 3/4}</code>, 2 bit <br> <code>e ∈ {-2, -1, 0, 1}</code>, 2 bit</li>
</ul>
</li>
</ul>
<p><img alt="" src="images/repr/float4.png" /></p>
<blockquote></blockquote>
<p><a href="http://www.mathworks.com/company/newsletters/news_notes/pdf/Fall96Cleve.pdf">http://www.mathworks.com/company/newsletters/news_notes/pdf/Fall96Cleve.pdf</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>IEEE 754 single & double</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Precisione singola: 32 bit<ul>
<li>1 x segno, 8 x esponente, 23 x frazione</li>
</ul>
</li>
<li>Precisione doppia: 64 bit<ul>
<li>1 x segno, 11 x esponente, 52 x frazione</li>
</ul>
</li>
</ul>
<p><img alt="" src="images/repr/ieee754-32-ex.svg" />
<img alt="" src="images/repr/ieee754-64.svg" /></p>
<blockquote></blockquote>
<p><a href="https://www.wikihow.com/Convert-a-Number-from-Decimal-to-IEEE-754-Floating-Point-Representation">https://www.wikihow.com/Convert-a-Number-from-Decimal-to-IEEE-754-Floating-Point-Representation</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>IEEE 754 half-precision</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Rappresentazione usata nelle GPU, per velocizzare i calcoli</li>
<li><code>-118.625 = -1110110.101<sub>2</sub> = -1.110110101<sub>2</sub> × 2<sup>6</sup></code></li>
<li>All’esponente, su 5 bit, bisogna sommare <code>15</code> (<code>=2<sup>(5 − 1)</sup> − 1</code>)</li>
</ul>
<p><img alt="" src="images/repr/ieee754-16-ex.svg" /></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Algebra di Boole</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Algebra di Boole</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>L’algebra di Boole è un formalismo che opera su variabili (dette <em>variabili booleane</em>)</li>
<li>Le variabili booleane possono assumere due soli valori: <code>vero</code>, <code>falso</code></li>
<li>Sulle variabili booleane è possibile definire delle funzioni (dette <em>funzioni booleane</em>)</li>
<li>Anche le funzioni booleane possono assumere solo i due valori <code>vero</code> e <code>falso</code></li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Funzione e tabella di verità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una <em>tabella di verità</em> permette di definire una <em>funzione booleana</em></li>
<li>Valore risultante per ciascuna configurazione dei valori in ingresso</li>
<li>A volte, <em>specifica incompleta</em> (certe configurazioni di ingressi non possono verificarsi) → Non è specificato alcun valore</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F<sub>1</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Operatori di base</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Algebra di Boole: basata su un insieme di operatori</li>
<li>Semplici funzioni, specificate con tabelle di verità</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A·B</th>
<th>A+B</th>
<th>A⊕B</th>
<th>A↑B</th>
<th>A↓B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>¬A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Espressione booleana</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/hair-logic.svg">
        
      </figure><ul>
<li>Operatori possono essere combinati in espressioni</li>
<li>Altra forma di definizione di funzioni booleane</li>
<li>Es. <code>F<sub>2</sub>(A, B, C) = A·B + C</code></li>
</ul>
<table>
<thead>
<tr>
<th>Operatore</th>
<th>Simbolo</th>
</tr>
</thead>
<tbody>
<tr>
<td>And</td>
<td>· (∧)</td>
</tr>
<tr>
<td>Or</td>
<td>+ (∨)</td>
</tr>
<tr>
<td>Not</td>
<td>¬</td>
</tr>
<tr>
<td>Xor</td>
<td>⊕</td>
</tr>
<tr>
<td>Nand</td>
<td>↑</td>
</tr>
<tr>
<td>Nor</td>
<td>↓</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Proprietà degli operatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th>Proprietà</th>
<th>Not</th>
</tr>
</thead>
<tbody>
<tr>
<td>Complemento</td>
<td>¬¬A = A</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Proprietà</th>
<th>And</th>
<th>Or</th>
</tr>
</thead>
<tbody>
<tr>
<td>Commutativa</td>
<td>A · B = B · A</td>
<td>A + B = B + A</td>
</tr>
<tr>
<td>Associativa</td>
<td>(A·B) · C = A · (B·C)</td>
<td>(A+B) + C = A + (B+C)</td>
</tr>
<tr>
<td>Distributiva</td>
<td>A + (B·C) = (A+B) · (A+C)</td>
<td>A · (B+C) = (A·B) + (A·C)</td>
</tr>
<tr>
<td>Idempotenza</td>
<td>A · A = A</td>
<td>A + A = A</td>
</tr>
<tr>
<td>Identità</td>
<td>A · 1 = A</td>
<td>A + 0 = A</td>
</tr>
<tr>
<td>Del limite</td>
<td>A · 0 = 0</td>
<td>A + 1 = 1</td>
</tr>
<tr>
<td>Assorbimento</td>
<td>A · (A + B) = A</td>
<td>A + (A · B) = A</td>
</tr>
<tr>
<td>Inverso</td>
<td>A · ¬ A = 0</td>
<td>A + ¬A = 1</td>
</tr>
<tr>
<td>De Morgan</td>
<td>¬(A·B·C…) = ¬A + ¬B + ¬C…</td>
<td>¬(A+B+C…) = ¬A · ¬B · ¬C…</td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>Attenzione a De Morgan: errore comune!</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>De Morgan</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint lang-py" data-lang="py"><code>if x1 == x2 and y1 == y2:
    print("the points are equal")
</code></pre>
<pre class="prettyprint lang-py" data-lang="py"><code>if x1 != x2 or y1 != y2:  # not (x1 == x2 and y1 == y2)
    print("the points are different")
</code></pre>
<ul>
<li>Python permette di confrontare tuple</li>
</ul>
<pre class="prettyprint lang-py" data-lang="py"><code>pt1 = x1, y1
pt2 = x2, y2
if pt1 != pt2:
    print("the points are different")
</code></pre></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Forme canoniche</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Somma di Prodotti (SP)</strong>: si considerano le righe a 1<ul>
<li><code>F<sub>1</sub>(A, B, C) = (¬A·¬B·¬C) + (¬A·B·C) + (A·¬B·C) + (A·B·¬C) + (A·B·C)</code></li>
</ul>
</li>
<li><strong>Prodotto di Somme (PS)</strong>: si considerano le righe a 0, <em>negate</em><ul>
<li><code>F<sub>1</sub>(A, B, C) = (A + B + ¬C) · (A + ¬B + C) · (¬A + B + C)</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F<sub>1</sub></th>
<th>→ Forma canonica...</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Cenni di logica</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Proposizione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Frase dichiarativa di senso compiuto che possa esser riconosciuta come “vera” o “falsa”<ul>
<li><strong>Principio di non contraddizione</strong>: un enunciato non può essere contemporaneamente vero e falso</li>
<li><strong>Principio del terzo escluso</strong>: un enunciato è vero o falso, non esiste una terza possibilità (<em>tertium non datur</em>)</li>
</ul>
</li>
<li>Ad esempio, sono proposizioni:<ul>
<li>“Il cane è un animale” - “2 = 1” - “I triangoli hanno tre lati”</li>
</ul>
</li>
<li>... Mentre non lo sono:<ul>
<li>“Il cane” - “Che ore sono?” - “Se 2 = 1” - “Non fumare!” - “Io sono bugiardo” (*)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>(*) Paradosso: non si può stabilire se la frase è vera o falsa</p>
<p>Tarsia @ UniPI: <a href="http://people.dm.unipi.it/tarsia/dida1011/logins05.pdf">http://people.dm.unipi.it/tarsia/dida1011/logins05.pdf</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Connettivi logici</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gli operatori booleani si usano anche con le proposizioni<ul>
<li>“e” (<em>congiunzione</em>, ∧)</li>
<li>“o” (<em>disgiunzione</em>, ∨)</li>
<li>“non” (<em>negazione</em>, ¬)</li>
<li>Valgono le proprietà già viste</li>
</ul>
</li>
<li>In logica, chiamati <em>connettivi</em><ul>
<li>Servono a legare proposizioni in forma più complessa</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Connettivo condizionale o implicazione logica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Esprime il legame “se” ... “allora”<ul>
<li>P: “io penso” (<em>premessa</em>)</li>
<li>Q: “io esisto” (<em>conseguenza</em>)</li>
<li>P ⇒ Q: “se penso allora esisto”</li>
</ul>
</li>
<li>P ⇒ Q si può leggere nei seguenti modi:<ul>
<li>Se P allora Q</li>
<li>Da P segue Q</li>
<li>P è <em>condizione sufficiente</em> per Q (se P è vera, allora Q è vera)</li>
<li>Q è <em>condizione necessaria</em> per P (se Q è falsa, allora P è falsa)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Verità dell'implicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>P ⇒ Q è falsa solo in un caso: quando P è vera e Q è falsa<ul>
<li>¬(P ⇒ Q) = (P ∧ ¬Q)</li>
</ul>
</li>
<li>Ne consegue che P ⇒ Q è vera se P è falsa o Q è vera<ul>
<li>P ⇒ Q = ¬(P ∧ ¬Q) = <em>[De Morgan]</em> <br> ¬P ∨ ¬(¬Q) = <em>[Doppia negazione]</em> <br> ¬P ∨ Q</li>
</ul>
</li>
<li>Esempi di implicazioni vere:<ul>
<li>“Se 5 è un numero allora Roma è una città”</li>
<li>“Se Parigi è la capitale d'Italia, allora 5 + 5 = 10”</li>
</ul>
</li>
<li>L'mplicazione <strong>non</strong> soddisfa la proprietà commutativa:<ul>
<li>(P ⇒ Q) ≠ (Q ⇒ P)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Doppia implicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>P ⇔ Q: valgono contemporaneamente le implicazioni P ⇒ Q e Q ⇒ P</li>
<li>P ⇔ Q è vera quando P e Q sono entrambe vere o entrambe false<ul>
<li>Applichiamo proprietà distributiva e proprietà dell'inverso</li>
<li>(P ⇒ Q) ∧ (Q ⇒ P) = <br> (¬P ∨ Q) ∧ (¬Q ∨ P) = <br> ((¬P) ∧ (¬Q ∨ P)) ∨ (Q ∧ ((¬Q) ∧ P)) = <br> ((¬P) ∧ ¬Q) ∨ (¬P ∧ P) ∨ ((P ∧ Q) ∨ (¬Q ∧ Q)) = <br> (P ∧ Q) ∨ (¬P ∧ ¬Q)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Deduzione logica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un <em>teorema</em> si riconduce all’implicazione P ⇒ Q<ul>
<li>P (<em>ipotesi</em>): proposizione che si assume vera</li>
<li>Q (<em>tesi</em>): proposizione di cui si vuole dedurre la verità</li>
</ul>
</li>
<li>Processo di <em>deduzione logica</em>, o <em>dimostrazione</em>, deve seguire ben precise regole di <em>inferenza</em><ul>
<li>Dimostrazione diretta (<em>modus ponens</em>)</li>
<li>Dimostrazione per assurdo (<em>modus tollens</em>)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dimostrazione diretta, modus ponens</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Schema di ragionamento</li>
</ul>
<table>
<thead>
<tr>
<th>Premessa</th>
<th>Conseguenza</th>
</tr>
</thead>
<tbody>
<tr>
<td>(P ⇒ Q) vera <br> P vera</td>
<td>Q vera</td>
</tr>
</tbody>
</table>
<ul>
<li>Esempio<ul>
<li>Se c'è sole, Ugo arriva in bici (implicazione)</li>
<li>C'è sole (fatto)</li>
<li>Ugo arriva in bici (deduzione)</li>
</ul>
</li>
<li>Alla base dei sillogismi aristotelici (con quantificatori)<ul>
<li><em>Premessa maggiore</em>: “Tutti gli uomini sono mortali”</li>
<li><em>Premessa minore</em>: “Socrate è un uomo”</li>
<li><em>Conclusione</em>: “Socrate è mortale”</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Osservazioni sul modus ponens</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Il solo fatto di sapere che P ⇒ Q è vera non consente di concludere niente su P e Q</li>
<li>Sono possibili dimostrazioni con più passaggi intermedi<ul>
<li>Se sono vere le implicazioni P ⇒ R, R ⇒ Q e se P è vera, allora è vera anche Q</li>
<li>((P ⇒ R) ∧ (R ⇒ Q) ∧ P) ⇒ Q</li>
</ul>
</li>
<li>Schema di ragionamento</li>
</ul>
<table>
<thead>
<tr>
<th>Premessa</th>
<th>Conseguenza</th>
</tr>
</thead>
<tbody>
<tr>
<td>(P ⇒ R) vera <br> (R ⇒ Q) vera <br> P vera</td>
<td>Q vera</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dimostrazione per assurdo, modus tollens</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se è vera l’implicazione ¬Q ⇒ ¬P ed è vera P, allora è vera anche Q</li>
<li>Schema di ragionamento</li>
</ul>
<table>
<thead>
<tr>
<th>Premessa</th>
<th>Conseguenza</th>
</tr>
</thead>
<tbody>
<tr>
<td>(¬Q ⇒ ¬P) vera <br> P vera</td>
<td>Q vera</td>
</tr>
</tbody>
</table>
<ul>
<li>Esempio di teorema<ul>
<li>P: m·n ≠ 0</li>
<li>Q: (m ≠ 0) ∧ (n ≠ 0)</li>
<li>Dimostrazione per assurdo: ¬Q ⇒ ¬P</li>
<li>Se (m = 0) oppure (n = 0), allora m·n = 0</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Predicato, o enunciato aperto</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Frase che contiene <em>variabili</em><ul>
<li>La verità della frase dipende dal valore delle variabili</li>
<li>Se variabili sostituite da valori, diventa proposizione</li>
</ul>
</li>
<li>Esempio<ul>
<li>P(x): “x è un numero dispari”</li>
</ul>
</li>
<li>Occorre definire il <em>dominio</em> delle variabili</li>
<li><em>Insieme di verità</em> del predicato<ul>
<li>Valori delle variabili che rendono vero l'enunciato</li>
<li>Sottoinsieme del dominio delle variabili</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Predicati con connettivi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>P(x) ∧ Q(x) -- Vero per gli x che rendono veri entrambi i pred.</li>
<li>P(x) ∨ Q(x) -- Vero per gli x che rendono vero almeno un pred.</li>
<li>¬P(x) -- Vero per gli x che rendono falso il pred.</li>
<li>P(x) ⇒ Q(x) -- Vero per gli x che rendono falso P oppure vero Q</li>
<li>P(x) ⇔ Q(x) -- Vero per gli x che rendono i pred. entrambi falsi o entrambi veri</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Quantificatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un predicato può essere trasformato in una proposizione in due modi<ul>
<li>Sostituendo la variabili con valori</li>
<li><em>Quantificando</em> le sue variabili</li>
<li>Una variabile legata ad un quantificatore si dice <em>vincolata</em>, altrimenti <em>libera</em></li>
</ul>
</li>
<li>I quantificatori logici sono due<ul>
<li>Quantificatore <strong>universale</strong></li>
<li>Quantificatore <strong>esistenziale</strong></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Quantificatore universale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una data proprietà vale per tutti i valori possibili delle variabili</li>
<li><code>∀x, P(x)</code> -- “Per ogni x, P(x) è vero”</li>
<li>Esempi<ul>
<li>∀n ∈ N, n è multiplo di 4 ⇒ n è pari</li>
<li>∀x ∈ R ∀y ∈ R, (x + y)<sup>2</sup> = x<sup>2</sup> + 2xy + y<sup>2</sup></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Quantificatore esistenziale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una data proprietà vale per almeno un valore delle variabili</li>
<li><code>∃x : P(x)</code> -- “Esiste almeno un x tale che P(x) è vero”</li>
<li>Esempi<ul>
<li>∃n ∈ N: n è pari -- Esiste almeno un numero pari</li>
<li>∃x ∈ R: 2x + 1 = 0 -- L'equazione ammette almeno una soluzione</li>
</ul>
</li>
<li>Enunciati con ∄ riformulati con ∀ e negando il predicato<ul>
<li>∄x : x<sup>2</sup> &lt; 0</li>
<li>∀x, x<sup>2</sup> ≥ 0</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Proprietà dei quantificatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I quantificatori sono sostanzialmente <em>congiunzioni</em> o <em>disgiunzioni</em> allargate a tutti gli elementi di un insieme</li>
<li>Due quantificatori dello stesso tipo <em>possono</em> essere scambiati di posto senza alterare la verità dell’enunciato</li>
<li>Invece, due quantificatori di diverso tipo <em>non possono</em> essere scambiati di posto</li>
<li>I seguenti enunciati sono ben diversi<ul>
<li>∀x, ∃y : y ≥ x</li>
<li>∃y : ∀x, y ≥ x</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Negazione con quantificatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Per negare un enunciato che contiene quantificatori, occorrono due modifiche:<ul>
<li>(1) Scambiare tra loro quantificatore universale ∀ e quantificatore esistenziale ∃</li>
<li>(2) Negare il predicato</li>
</ul>
</li>
<li>Esempi<ul>
<li>¬(∀x, P(x)) ⇔ ∃x : ¬P(x)</li>
<li>¬(∃x : P(x)) ⇔ ∀x, ¬P(x)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Operazioni tra insiemi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Siano definiti due insiemi: A = {x : P(x)}, B = {x : Q(x)}</li>
</ul>
<table>
<thead>
<tr>
<th>Proprietà</th>
<th>Op. tra insiemi</th>
<th>Op. tra predicati</th>
</tr>
</thead>
<tbody>
<tr>
<td>Commutativa</td>
<td>A ∪ B = B ∪ A</td>
<td>P ∨ Q ⇔ Q ∨ P</td>
</tr>
<tr>
<td>Commutativa</td>
<td>A ∩ B = B ∩ A</td>
<td>P ∧ Q ⇔ Q ∧ P</td>
</tr>
<tr>
<td>Associativa</td>
<td>(A ∪ B) ∪ C = A ∪ (B ∪ C)</td>
<td>(P ∨ Q) ∨ R ⇔ P ∨ (Q ∨ R)</td>
</tr>
<tr>
<td>Associativa</td>
<td>(A ∩ B) ∩ C = A ∩ (B ∩ C)</td>
<td>(P ∧ Q) ∧ R ⇔ P ∧ (Q ∧ R)</td>
</tr>
<tr>
<td>Distributiva</td>
<td>(A ∪ B) ∩ C = (A ∩ C) ∪ (B ∩ C)</td>
<td>(P ∨ Q) ∧ R ⇔ (P ∧ R) ∨ (Q ∧ R)</td>
</tr>
<tr>
<td>Distributiva</td>
<td>(A ∩ B) ∪ C = (A ∪ C) ∩ (B ∪ C)</td>
<td>(P ∧ Q) ∨ R ⇔ (P ∨ R) ∧ (Q ∨ R)</td>
</tr>
<tr>
<td>Doppia negazione</td>
<td>(B<sup>C</sup>)<sup>C</sup> = B</td>
<td>¬(¬P) ⇔ P</td>
</tr>
<tr>
<td>De Morgan</td>
<td>(A ∪ B)<sup>C</sup> = A<sup>C</sup> ∩ B<sup>C</sup></td>
<td>¬(P ∨ Q) ⇔ ¬P ∧ ¬Q</td>
</tr>
<tr>
<td>De Morgan</td>
<td>(A ∩ B)<sup>C</sup> = A<sup>C</sup> ∪ B<sup>C</sup></td>
<td>¬(P ∧ Q) ⇔ ¬P ∨ ¬Q</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Principio di induzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sia P(n) un predicato definito ∀n ≥ k, (n ∈ N, k ∈ N) tale che:<ul>
<li>(1) P(k) è vera</li>
<li>(2) ∀n ≥ k : supponendo P(n) vera segue che anche P(n+1) è vera</li>
<li>Allora P(n) risulta vera per ogni n ≥ k</li>
</ul>
</li>
<li>In una formula:<ul>
<li>(P(k) ∧ (∀n ≥ k, P(n) ⇒ P(n + 1))) ⇒ (∀n ≥ k, P(n))</li>
</ul>
</li>
<li>Esercizio: dimostrare la formula di Gauss<ul>
<li>1 + 2 + 3 + ··· + n = n (n + 1) / 2</li>
</ul>
</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="theme/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://sowide.unipr.it/tomamic">sowide.unipr.it/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>