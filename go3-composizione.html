<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Liste e composizione</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="theme/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/oop/lego-blocks.png"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Slice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/shopping-list.jpg">
        
      </figure><ul>
<li>Sequenza di elementi, dello stesso <strong>tipo</strong><ul>
<li>L'intera lista (<em>slice</em>) pu√≤ essere assegnata ad una variabile, cos√¨ diamo un <strong>nome</strong> alla lista</li>
</ul>
</li>
<li>I singoli elementi sono <strong>numerati</strong><ul>
<li>Gli indici partono da 0!</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>toBuy := []string{"spam", "eggs", "beans"}
</code></pre>
<pre class="prettyprint" data-lang="go"><code>rainfallData := []int{13, 24, 18, 15}
</code></pre>
<pre class="prettyprint" data-lang="go"><code>resultsByMonth := make([]int, 12)  // 12 times 0
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Accesso agli elementi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/wile-coyote.png">
        
      </figure><ul>
<li><strong>Attenzione ad usare indici validi!</strong><ul>
<li><em>Lunghezza</em> attuale di una lista <code>s</code>: <code>len(s)</code></li>
<li>Elementi <em>numerati</em> da <code>0</code> a <code>len(s)-1</code></li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>toBuy := []string{"spam", "eggs", "beans", "bacon"}
n := len(toBuy)        // 4

Println(toBuy[0])      // "spam"
Println(toBuy[1])      // "eggs"
Println(toBuy[n-1])    // "bacon"

toBuy[1] = "ketchup"   // replace a value
Println(toBuy[1])      // "ketchup"
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Porzioni di lista</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/month-list.svg">
        
      </figure><ul>
<li>Selezione degli elementi tra...<ul>
<li>il primo indice (<em>compreso</em>)...</li>
<li>ed il secondo indice (<em>escluso</em>)</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>months := []string{"Jan", "Feb", "Mar",
                   "Apr", "May", "Jun",
                   "Jul", "Aug", "Sep",
                   "Oct", "Nov", "Dec"}

spring := months[2:5]       // [Mar Apr May]
quart1 := months[:3]        // [Jan Feb Mar]
quart4 := months[9:]        // [Oct Nov Dec]
wholeYear := months[:]      // The whole list
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Concatenazione, rimozione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>toBuy := []string{"spam", "eggs", "beans"}
Println(toBuy)

toBuy = append(toBuy, "bacon")          // add to the end
Println(toBuy)

moreStuff := []string{"sausage", "mushrooms"}
toBuy = append(toBuy, moreStuff...)     // concatenation
Println(toBuy)

toBuy = append(toBuy[:2], toBuy[3:]...)  // remove val @ 2
Println(toBuy)
</code></pre>
<blockquote></blockquote>
<p><a href="https://github.com/golang/go/wiki/SliceTricks">https://github.com/golang/go/wiki/SliceTricks</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Stringhe e liste</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong><code>Join</code></strong> e <strong><code>Split</code></strong>, da lista a stringa e viceversa<ul>
<li>Nel package <em><code>strings</code></em></li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>someDays := []string{"tue", "thu", "sat"}
someTxt := strings.Join(someDays, "|")
// a single string: "tue|thu|sat"

otherTxt := "mon|wed|fri|sun"
otherDays := strings.Split(otherTxt, "|")
// a list of strings: {"mon", "wed", "fri", "sun"}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Cicli su liste: for</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>shoppingList := []string{"spam", "eggs", "bacon", "ketchup"}

Println("Your shopping list contains:")

for _, value := range shoppingList {
    fmt.Println(value)
}
// for index, value := range shoppingList {
//    fmt.Println(index, value)
// }
</code></pre>
<ul>
<li>Ad ogni iterazione, a <code>value</code> √® assegnato un diverso elemento della lista <code>shoppingList</code></li>
<li><code>index</code> e/o <code>value</code> possono essere omessi (sostituiti con <code>_</code>)</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Cicli su stringhe: for</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Si pu√≤ usare un ciclo <code>for</code> su qualsiasi sequenza</li>
<li>Anche su <em>stringa</em>: sequenza <em>immutabile</em> di caratteri (UTF-8)</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>for index, value := range "Hello, üåê!" {
    fmt.Println(index, value)
}

for _, x := range "Hello, üåê!" {
    fmt.Printf("%c  ", x)  // in package fmt
    fmt.Printf("%d\n", x)  // &lt;https://golang.org/pkg/fmt/&gt;
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Composizione</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Lista di palline</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>var balls = []*Ball{NewBall(40, 80), NewBall(80, 40)}

func tick() {
    FillCanvas(Color{255, 255, 255}) // BG
    for _, b := range balls {
        b.Move()
        DrawRect(Color{100, 100, 100}, b.Position()) // FG
    }
}
func main() {
    InitCanvas(Size{ArenaW, ArenaH})
    MainLoop(tick, 1000/30) // Millis
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://www.ce.unipr.it/gopherjs/?p3_ball.go">http://www.ce.unipr.it/gopherjs/?p3_ball.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Composizione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/ball-arena.svg">
        
      </figure><ul>
<li>Associazione <strong>has-a</strong>, <strong>part-of</strong> tra oggetti<ul>
<li>Una arena <em>contiene</em> diverse palline</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>type BallArena struct { balls []*Ball }
func (a *BallArena) Add(b *Ball) {
    a.balls = append(a.balls, b)
}
func (a *BallArena) MoveAll() {
    for i, b := range a.balls {
        b.Move(); Println("Ball", i, b.Position())
    }
}
func main() {
    var arena = &amp;BallArena{}
    arena.Add(NewBall(40, 80)); arena.Add(NewBall(80, 40))
    arena.MoveAll() // ...
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Interfacce</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Livelli di astrazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/inheritance.png">
        
      </figure><ul>
<li>Relazione <strong>is-a</strong> tra classi<ul>
<li>Specializzazione, sotto-insieme</li>
</ul>
</li>
<li>Es. classificazioni in biologia<ul>
<li><em>Vertebrati</em> sottoclasse degli <em>animali</em></li>
<li><em>Mammiferi</em> sottoclasse dei <em>vertebrati</em></li>
<li><em>Felini</em> sottoclasse dei <em>mammiferi</em></li>
<li><em>Gatti</em> sottoclasse dei <em>felini</em></li>
</ul>
</li>
<li>Ogni sottoclasse...<ul>
<li>Eredita le caratteristiche della classe base</li>
<li>Ma introduce delle specializzazioni</li>
</ul>
</li>
<li>In <strong>Go</strong> non c'√® <em>ereditariet√†</em>, ma <strong>interfacce</strong></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fattoria parlante</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/animals.png">
        
      </figure><ul>
<li>Noi definiremo una <strong>interfaccia</strong> come astrazione di base</li>
<li>Es. <code>Animal</code>:<ul>
<li>Tutti gli animali fanno un verso (<em>interfaccia</em>)</li>
<li>Ogni animale fa un verso diverso (<em>polimorfismo</em>)</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>type Animal interface {
    Say()
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://www.ce.unipr.it/gopherjs/?p3_animals.go">http://www.ce.unipr.it/gopherjs/?p3_animals.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Classi concrete</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/polymorphism.png">
        
      </figure><pre class="prettyprint" data-lang="go"><code>type Dog struct { name string }
func NewDog(name string) *Dog { return &amp;Dog{name} }
func (d *Dog) Say() {
    Println("I'm " + d.name + " Dog. I say: WOOF!")
}

type Cat struct { name string }
func NewCat(name string) *Cat { return &amp;Cat{name} }
func (c *Cat) Say() {
    Println("I'm " + c.name + " Cat. I say: MEOW!")
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lista di oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/peppa.png">
        
      </figure><pre class="prettyprint" data-lang="py"><code>d := NewDog("Danny")
c := NewCat("Candy")
p1 := NewPig("Peppa")
p2 := NewPig("George")
animals := []Animal{d, c, p1, p2}

for _, a := range animals {
    a.Say()
}
</code></pre>
<pre class="prettyprint" data-lang="output"><code>I am Danny Dog. I say: WOOF!
I am Candy Cat. I say: MEOW!
I am Peppa Pig. I say: OINK!
I am George Pig. I say: OINK!
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Interfacce</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/actors.svg">
        
      </figure><ul>
<li><code>Actor</code>: <em>interfaccia</em><ul>
<li>Dichiara un metodo <code>move</code> ecc.</li>
</ul>
</li>
<li>Vari attori: <em>classi implementazione</em><ul>
<li>Implementano caratteristiche di <code>Actor</code></li>
<li>Definiscono comportamenti specifici</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>type Actor interface {
    Move()
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Generalizzazione e riuso</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>type Arena struct { actors []Actor }
func (a *Arena) Add(c Actor) {
    a.actors = append(a.actors, c)
}
func (a *Arena) MoveAll() {
    for i, c := range a.actors {
        c.Move()
    }
}
</code></pre>
<ul>
<li>Codice dipendente dalle classi pi√π astratte, pi√π in alto nella gerarchia<ul>
<li><code>Arena</code> riutilizzabile creando nuove classi derivate di <code>Actor</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sostituzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/actor.svg">
        
      </figure><pre class="prettyprint" data-lang="go"><code>arena.Add(NewBall(40, 80))
arena.Add(NewGhost(120, 40)) // ...
arena.MoveAll()
</code></pre>
<ul>
<li>Principio di <strong>sostituzione</strong> di Liskov<ul>
<li>Si pu√≤ sempre usare un oggetto di una <em>classe implementazione</em>, al posto di uno della <em>interfaccia</em></li>
</ul>
</li>
<li>Relazione <em>has-a</em> tra un oggetto <code>Arena</code> e gli oggetti <code>Actor</code> che contiene</li>
<li>Relazione <em>is-a</em> tra classi implementazione (<code>Ball</code> e <code>Ghost</code>) e interfaccia (<code>Actor</code>)</li>
</ul>
<blockquote></blockquote>
<p><a href="http://www.ce.unipr.it/gopherjs/?g2d.go">http://www.ce.unipr.it/gopherjs/?g2d.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ereditariet√† e polimorfismo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Classe implementazione</strong><ul>
<li>Implementa le caratteristiche della interfaccia</li>
<li>Pu√≤ definire nuove caratteristiche specifiche</li>
</ul>
</li>
<li><strong>Metodo polimorfo</strong><ul>
<li>Definito in modo diverso nelle classi implementazione</li>
<li>Attori diversi possono muoversi in modo diverso</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>type Ghost struct { x, y int }  // ...
func (g *Ghost) Move() {
    dx := 5 * RandInt(-1, 1)
    dy := 5 * RandInt(-1, 1)
    g.x = (g.x + dx + ArenaW) % ArenaW
    g.y = (g.y + dy + ArenaH) % ArenaH
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Attori e arena</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>type Ghost struct {
    arena *Arena
    x, y  int
}
func NewGhost(arena *Arena, x, y int) *Ghost {
    g := &amp;Ghost{arena, x, y}  // save a ref to the arena
    arena.Add(g)              // register yourself into the arena
    return g
}
func (g *Ghost) Move() {
    dx, dy := 5 * RandInt(-1, 1), 5 * RandInt(-1, 1)
    as := g.arena.Size()      // ref to arena
    g.x = (g.x + dx + as.W) % as.W
    g.y = (g.y + dy + as.H) % as.H
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://www.ce.unipr.it/gopherjs/?p3_bounce.go">http://www.ce.unipr.it/gopherjs/?p3_bounce.go</a></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Animazione dei personaggi</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Rimbalzi nel browser</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>var sprites = LoadImage("sprites.png")
var arena = NewArena(320, 240)
var turtle = NewTurtle(arena, 80, 80)  // actor knows the arena
func tick() {
    arena.MoveAll()  // Game logic
    FillCanvas(Color{255, 255, 255})
    for _, a in arena.Actors() {
        // Cut an area from a larger image
        DrawImageClip(sprites, a.Position(), a.Symbol())
    }
}
func main() {
    NewGhost(arena, 120, 80); NewBall(arena, 40, 80) // ...
    InitCanvas(arena.Size())
    MainLoop(tick, 1000 / 30)
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Controllo da tastiera</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/bounce.png">
        
      </figure><pre class="prettyprint" data-lang="python"><code>func keydown(code) {
    if code == "ArrowUp" { turtle.GoUp() }
    else if code == "ArrowDown" { turtle.GoDown() }
    else if code == "ArrowLeft" { turtle.GoLeft() }
    else if code == "ArrowRight" { turtle.GoRight() }
}
func keyup(code) {
    turtle.Stay()
}
func main() {
    // ...
    HandleKeyboard(keydown, keyup)
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://www.ce.unipr.it/gopherjs/?p3_bounce.go">http://www.ce.unipr.it/gopherjs/?p3_bounce.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Collisioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/collision.svg"><img src="images/oop/reflection.png">
        
      </figure><ul>
<li>Molti algoritmi di <em>collision detection</em><ul>
<li>Casi semplici: intersezione di rettangoli</li>
</ul>
</li>
<li>In caso di collisione, <code>Arena</code>...<ul>
<li>Invoca il metodo <code>collide</code> di entrambi gli oggetti</li>
<li>Collisione tra personaggio <code>self</code> e personaggio <code>other</code> (secondo parametro)</li>
</ul>
</li>
<li>Possibili errori nel calcolo del rimbalzo<ul>
<li>Di solito accettabili</li>
<li>Altrimenti, applicare correzioni</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Urti delle palline</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>func (b *Ball) Collide(other Actor) {
    _, ok := other.(*Ghost)
    if !ok {
        op := other.Position()
        if op.X &lt; b.x { b.dx = b.speed }
        else { b.dx = -b.speed }
        if op.Y &lt; b.y { b.dy = b.speed }
        else { b.dy = -b.speed }
    }
}
</code></pre>
<ul>
<li><em>Downcast</em>: <code>other.(*Ghost)</code><ul>
<li>Converte l'oggetto <code>other</code> come istanza di <code>Ghost</code></li>
<li>Restituisce un riferimento a <code>Ghost</code> ed un <code>bool</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercizi</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>3.1 Ellisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ellipse.svg">
        
      </figure><ul>
<li>Classe che modella un'ellisse</li>
<li>Campi privati (parametri del costruttore)<ul>
<li>Semiassi: <code>a, b</code></li>
</ul>
</li>
<li>Metodi pubblici per ottenere...<ul>
<li>Area: <code>œÄ‚ãÖa‚ãÖb</code></li>
<li>Distanza focale: <code>2‚ãÖ‚àö|a<sup>2</sup> - b<sup>2</sup>|</code></li>
</ul>
</li>
<li>Nel corpo principale del programma...<ul>
<li>Creare un oggetto con dati forniti dall'utente</li>
<li>Visualizzare area e distanza focale dell'ellisse</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.2 Animazione di una pallina</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/street-fighter.jpg">
        
      </figure><ul>
<li>Partire dalla classe <code>Ball</code> vista a lezione</li>
<li>Eseguire l'animazione<ul>
<li>Per ogni frame, chiamare il metodo <code>Move</code> della pallina</li>
<li>Rappresentare un rettangolo o un cerchio nella posizione aggiornata della pallina</li>
</ul>
</li>
<li>Modificare per√≤ il metodo <code>Move</code><ul>
<li>La pallina si sposta sempre di pochi pixel in orizzontale</li>
<li>La pallina non si sposta verticalmente</li>
<li>Se esce dal bordo destro, ricompare al bordo sinistro e viceversa</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.3 Classe degli invasori spaziali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/invaders-path.jpg">
        
      </figure><ul>
<li>Creare una classe <code>Invader</code>, che contenga i dati ed il comportamento dell'alieno<ul>
<li>Campi privati: <code>x</code>, <code>y</code>, <code>dx</code></li>
<li>Metodo <code>Move</code> per avanzare</li>
<li>Metodo <code>Position</code> per ottenere la posizione attuale</li>
</ul>
</li>
<li>Istanziare un oggetto <code>Invader</code> e farlo muovere sullo schermo<ul>
<li>Chiamare il metodo <code>Move</code> ad ogni ciclo</li>
<li>Visualizzare un rettangolo nella posizione corrispondente</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Definire nella classe delle opportune costanti</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.4 Lista di invasori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/invaders-path.jpg">
        
      </figure><ul>
<li>Riusare la classe <code>Invader</code> (es. 3.3)</li>
<li>Creare inizialmente una lista di alieni, con posizioni di partenza diverse<ul>
<li>Memorizzare la posizione di partenza di ciascun alieno in opportuni campi privati</li>
<li>Lasciare a ciascun alieno uno spazio orizzontale di movimento di 150 pixel, a destra della posizione di partenza</li>
</ul>
</li>
<li>Farli avanzare tutti ad ogni ciclo, chiamando il metodo <code>Move</code> di ciascuno di essi</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="theme/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://sowide.unipr.it/tomamic">sowide.unipr.it/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>