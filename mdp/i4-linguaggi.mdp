title: Linguaggi formali
subtitle: Introduzione all'informatica
figure: images/comp/attack.jpg

---

title: Linguaggi formali
figure: images/comp/tangible.jpg

- Presenti in tutte le applicazioni
    - Linguaggi di programmazione
    - Linguaggi di marcatura (es. HTML, Latex)
    - Interazione uomo macchina (es. Google, Zork)
- Fondamentali in sw di sistema
    - Compilatori
    - Interpreti â€¦
- Paradigmatici nella teoria
    - Molti problemi riconducibili a quello dell'*appartenenza*: una stringa appartiene ad un linguaggio?

---

title: Alfabeti e stringhe

- Alfabeto `Î£`: insieme di simboli
- Stringa `s`: sequenza di simboli di `Î£`
    - `s âˆˆ Î£*`, insieme di tutte le stringhe
    - `Îµ`: stringa vuota
    - `|s|`: lunghezza della stringa `s`
- Linguaggio `L âŠ† Î£*`
    - Sottoinsieme di tutte le stringhe possibili
    - Grammatica: regole formali per definire le â€œ*stringhe ben formate*â€ di L
- Esempio: numeri romani da 1 a 1000
    - Alfabeto `{I, V, X, L, C, D, M}` + regole...

---

title: Concatenazione di stringhe

- Operazione di concatenazione `â€¢`
    - Propr. associativa: `(x â€¢ y) â€¢ z = x â€¢ (y â€¢ z)`
    - Non commutativa: `x â€¢ y â‰  y â€¢ x`
    - `Î£*` chiuso rispetto a `â€¢: Î£* x Î£* â†’ Î£*`
- Potenza
    - `x^^n^^ = x â€¢ x â€¢ x â€¢ x â€¦ (n volte)`
- Elemento neutro `Îµ`
    - Stringa vuota, `âˆ€ x âˆˆ Î£*, Îµ â€¢ x = x â€¢ Îµ = x`

>

`<Î£*, â€¢, Îµ>`: monoide

---

title: Definizione di linguaggi

- Approccio **algebrico**: *espressioni regolari*
    - Linguaggio costruito a partire da linguaggi piÃ¹ elementari, con operazioni su linguaggi
- Approccio **generativo**: *grammatiche*
    - Regole per la generazione di stringhe appartenenti al linguaggio
- Approccio **riconoscitivo**: *automi*
    - Algoritmi per decidere se una stringa appartiene o no al linguaggio
---

title: Espressioni regolari
class: segue dark

---

title: Operazioni su linguaggi

- `L~~1~~` ed `L~~2~~` linguaggi su `Î£*` (due insiemi di stringhe)
- Unione: `L~~1~~ âˆª L~~2~~ = {x âˆˆ Î£* : x âˆˆ L~~1~~ âˆ¨ x âˆˆ L~~2~~}`
- Intersezione: `L~~1~~ âˆ© L~~2~~ = {x âˆˆ Î£* : x âˆˆ L~~1~~ âˆ§ x âˆˆ L~~2~~}`
- Complementazione: `L^^c^^ = {x âˆˆ Î£* : x âˆ‰ L}`

---

title: Concatenazione di linguaggi


- Concatenazione o prodotto:
    - `L~~1~~â€¢L~~2~~ = {x âˆˆ Î£* : x = x~~1~~â€¢x~~2~~, x~~1~~ âˆˆ L~~1~~, x~~2~~ âˆˆ L~~2~~}`
    - Es. `L~~1~~ = {ab, bb}; L~~2~~ = {aa, ab};` <br> `L~~1~~ â€¢ L~~2~~ = {abaa, abab, bbaa, bbab}`
- Potenza: `L^^n^^ = L â€¢ L^^n-1^^, nâ‰¥1; L^^0^^ = {Îµ}` per convenzione
    - Concatenazione diâ€Œ `n` stringhe qualsiasi di `L`
    - Es. `L = {ab, bb}; L^^2^^ = {abab, abbb, bbab, bbbb}`
- Stella di Kleene: `L* = âˆª L^^n^^, n = 0..âˆž`
    - Concatenazione arbitraria diâ€Œ stringhe di `L`

>

`L*`: chiusura riflessiva e transitiva di `L` rispetto a `â€¢`

---

title: Espressioni regolari

- Dato un alfabeto `Î£`, chiamiamo *espressione regolare* una stringa `r` sull'alfabeto `Î£ âˆª {+, *, (, ), â€¢, Ã˜}` t.c.:
    - `r = Ã˜`: linguaggio vuoto; oppure
    - `r âˆˆ Î£`: linguaggio con un solo simbolo; oppure
    - `r = s + t`: unione dei linguaggi `L(s)`, `L(t)`; oppure
    - `r = s â€¢ t`: concatenazione dei linguaggi `L(s)`, `L(t)`; oppure
    - `r = s*`: chiusura del linguaggio `L(s)`
    - (con `s` e `t` espressioni regolari; simbolo `â€¢` spesso implicito)
- *Linguaggi regolari*: rappresentabili con espressioni regolari (*â€œregexâ€*)

>

Esempio, con `Î£ = {a, b}`: <br> `a â€¢ (a + b)* â€¢ b`

---

title: Save the day with regex

![](images/comp/regex-xkcd.png)

---

title: Regex nelle applicazioni

- Concatenazione di caratteri: `goal`
- Unione tra espressioni (opzione): `one|two|three`
- Un car. da un insieme (o no): `[a-z]`, `[^a-z0-9]`
- Un carattere qualsiasi: `defin.tely`
- Ripetizioni (0+, 1+, 0-1): `goo*al`, `go+al`, `goo?al`
- Sottoespressione: `(left right )*halt`

![](images/comp/perl-problems.png)

---

title: Regex, classi di caratteri

- `[...]` per includere uno qualsiasi dei caratteri in parentesi
    - Singoli caratteri o intervalli di caratteri adiacenti
    - `[A-Z]` = qualsiasi lettera maiuscola
    - `[a-zABC]` = qualsiasi lettera minuscola oppure `A`, `B`, o `C`
- `[^...]` per escludere uno qualsiasi dei caratteri in parentesi
    - `[^0-9]` = qualsiasi carattere non numerico
- *PCRE*, Perl Compatible RegEx
    - Simboli speciali per identificare classi di caratteri
    - `\d` = numerico, ossia `[0-9]`
    - `\s` = `[ \t\r\n\f]`
    - `\w` = `[0-9a-zA-Z_]`
    - `\D` = non numerico, ossia `[^0-9]` (anche `\W` ecc.)

---

title: Regex, caratteri speciali

- `.` per un carattere qualsiasi
    - `A.B` riconosce la stringa `AoB`, `AwB`, `AOB` ecc.
- `\` escape, per segnalare sequenze speciali o considerare caratteri speciali come normali
    - `\?` cerca il `?`
- `^` corrisponde all'inizio del testo
- `$` corrisponde alla fine del testo
- `|` per alternativa tra due espressioni (unione)
    - `A|B` = carattere `A` o carattere `B`
- `(...)` per raggruppare sotto-espressioni
    - `ga(zz|tt)a` trova sia `gazza` che `gatta`

---

title: Regex, ripetizioni

- `{...}` per specificare il numero di ripetizioni
    - `\d{3,5}` sequenze di almeno tre cifre, al massimo cinque
- `*` zero o piÃ¹ occorrenze di unâ€™espressione
    - `(ab)*` riconosce `ab`, `abab`, la stringa vuota, ma non riconosce `abba`
- `+` una o piÃ¹ occorrenze
    - `(ab)+` non riconosce la stringa vuota
- `?` zero o al piÃ¹ una occorrenza (parte opzionale)
    - `https?://\S*` riconosce sia url http che https

>

<http://www.zytrax.com/tech/web/regex.htm>

---

title: Regex, esempi

![](images/comp/codice-fiscale.png)

- Codice fiscale: <br> `^[A-Z]{6}[0-9]{2}[A-Z][0-9]{2}[A-Z][0-9]{3}[A-Z]$`
- Dominio: <br> `^[\w\-]+\.(it|com|org|net|eu|mobi)$`
- E-mail: <br> `^[\w\-\.]+@[\w\-\.]+\.[a-z]+$`
- File: `^.+\.zip$`
- Data: `^\d{2}/\d{2}/\d{4}$`

---

title: Regex, validazione form

code: html

    <script>
    function validate(val) {
        var expr = /^\d{2}\/\d{2}\/\d{4}$/;
        if (! expr.test(val)) {
            window.alert("Wrong date format");
            return false;
        }
        return true;
    }
    </script>

    <form onsubmit="return validate(usrdate.value)">
        Date (dd/mm/yyyy): <input name="usrdate">
        <input type="submit">
    </form>

---

title: Regex in Python

code: python

    >>> import re
    >>> text = "Though not quickly, he run the 5th lap steadily."
    >>> re.findall(r"[a-z]+ly", text)
    ['quickly', 'steadily']
    >>> re.sub(r"([0-9])([a-z]+)", r"\1<sup>\2</sup>", text)
    'Though not quickly, he run the 5<sup>th</sup> lap steadily.'
    >>> re.sub(r"([aeiou])\1+", r"\1", "troooppo miiiticoo!")
    'troppo mitico!'

>

<http://docs.python.org/3/library/re.html>

---

title: Grammatiche di Chomsky
class: segue dark

---

title: Grammatiche di Chomsky

- Grammatica `G = < V~~T~~, V~~N~~, P, S >`
    - `V~~T~~`: alfabeto finito di simboli **terminali**
    - `V~~N~~`: ... **non terminali** (variabili, categorie sintattiche)
    - `V = V~~T~~ âˆª V~~N~~`
    - `P`: insieme di **produzioni**, relaz. binarie `V* â€¢ V~~N~~ â€¢ V* x V*` <br> `<Î±, Î²> âˆˆ P` si indica con `Î± â†’ Î²`
    - `S âˆˆ V~~N~~`: **assioma**
- `L(G)`: insieme delle stringhe di terminali ottenibili con finite operazioni di riscrittura
    - Applicazione delle regole di produzione, in vario modo

---

title: Linguaggio generato da G

- *Derivazione diretta* `â‡’`: riscrittura di una stringa tramite applicazione di una regola di produzione
- *Derivazione* `â‡’*`: chiusura riflessiva e transitiva della derivazione diretta
- *Forma di frase*: stringa `x t.c. x âˆˆ V*, S â‡’* x`
- *Linguaggio generato* da `G`: forme di frase con soli simboli terminali
    - `L(G) = {x : x âˆˆ V~~T~~*, S â‡’* x}`
- *Equivalenza* tra `G~~1~~` e `G~~2~~`: `L(G~~1~~) = L(G~~2~~)`

---

title: Albero delle frasi
figure: images/comp/grammar1.png images/comp/grammar2.png
class: large-figure

- Rappresentazione delle (prime) frasi generate da una grammatica
- La radice dell'albero Ã¨ l'assioma
- Ogni nodo ha tanti figli, quante sono le produzioni applicabili
- Ogni figlio Ã¨ una *forma di frase*
- Le *foglie* sono stringhe del linguaggio
- Esempi:
    - `G~~1~~ = <{a,b}, {F}, P~~1~~, F>` <br> `P~~1~~ = {F â†’ ab, F â†’ aFb}`
    - `G~~2~~ = <{a,b}, {F,G}, P~~2~~, F>` <br> `P~~2~~ = {F â†’ ab, F â†’ aG, G â†’ Fb}`

---

title: Grammatiche equivalenti

- `G~~1~~ = <{a, b}, {S, A}, P, S>`, con produzioni:
    - `S â†’ b` <br> `S â†’ aA` <br> `A â†’ aS`
    - â€¦ genera il linguaggio `{a^^n^^b : n pari}`
- Anche `G~~2~~`, con produzioni:
    - `S â†’ Ab | b` <br> `A â†’ aAa | aa`
- Ed anche `G3`:
    - `S â†’ Ab` <br> `A â†’ Aaa | Îµ`

>

`|` per raggruppare diverse produzioni di uno stesso non-terminale

---

title: Esempio di generazione

- `G = <{a, b, c}, {S, B, C}, P, S>`
    - (1) `S â†’ aSBC`
    - (2) `S â†’ aBC`
    - (3) `CB â†’ BC`
    - (4) `aB â†’ ab`
    - (5) `bB â†’ bb`
    - (6) `bC â†’ bc`
    - (7) `cC â†’ cc`
    - â€¦ genera il linguaggio `{a^^n^^b^^n^^c^^n^^ : nâ‰¥1}`
- Esercizio: provare a generare `aaabbbccc`
    - Soluzione: applicare 1-1-2-3-3-3-4-5-5-6-7-7

---

title: Alberi di derivazione (sintattici)

- Esempio di grammatica **ambigua**: due interpretazioni valide per `a + a * a`
    - `V~~T~~ = {a, +, *, (, )};  V~~N~~ = {E};`
    - `E â†’ E+E | E*E | (E) | a`

![](images/comp/ambiguity.svg)

- Grammatica non ambigua (con precedenza tra operatori)
    - `E â†’ E+T | T` <br> `T â†’ Tâˆ—F | F` <br> `F â†’ (E) | a`

---

title: Classificazione di Chomsky
figure: images/comp/hierarchy.svg

- *Tipo 0*: grammatiche **ricorsivam. enumerabili** (RE)
    - `Î±AÎ² â†’ Î³` (*non limitate*)
- *Tipo 1*: grammatiche **contestuali** (CS)
    - `Î±AÎ² â†’ Î±Î³Î²`
- *Tipo 2*: grammatiche **non contestuali** (CF)
    - `A â†’ Î³`
- *Tipo 3*: grammatiche **regolari** (REG)
    - `A â†’ aB`, oppure `A â†’ b`, oppure `A â†’ Îµ` (REG destre)
    - Coincide con classe dei linguaggi definiti da *regex*

>

`A, B âˆˆ V~~N~~; a, b âˆˆ V~~T~~; Î±, Î², Î³ âˆˆ V*`

---

title: Linguaggi non contestuali
class: segue dark

---

title: Linguaggi non contestuali

- Controllo di *palindromi*, *bilanciamento di parentesi* e varie *simmetrie*
    - Es.: `{a^^n^^b^^n^^ : nâ‰¥1}` gen. da `S â†’ aSb | ab` (CF)
    - Es.: L. parentesi bilanciate gen. da `S â†’ SS | (S) | Îµ`
    - Ma non: `{a^^n^^b^^n^^c^^n^^ : nâ‰¥1}` (CS) (*)
- **Linguaggi di programmazione** comuni: grammatiche CF
    - Parentesi bilanciate: `S â†’ SS | (S) | Îµ`

>

(*) Nell'es. visto, sostituire (3) con: (3a) `CB â†’ HB`; (3b) `HB â†’ HC`; (3c) `HC â†’ BC`

---

title: Extended Backus-Naur Form (EBNF)

- Terminali tra virgolette
- `{...}`: parte ripetibile (0+), `[...]`: parte opzionale,
- `(...)`: raggruppamento, `|`: scelta

code: EBNF

    V~~T~~ = {"il", "gatto", "topo", "sasso", "mangia", "beve"}
    P = {
        frase = soggetto verbo complemento
        soggetto = articolo nome
        complemento = articolo nome
        articolo = "il"
        nome = "gatto" | "topo" | "sasso"
        verbo = "mangia" | "beve"
    }

- *â€œil gatto mangia il topoâ€* Ã¨ una frase del linguaggio

---

title: Espressioni infisse e prefisse

- *Notazione infissa*, con precedenza
    - Es.: `2 + 3 * 3`

code: ebnf

    expr = term {( "+" | "-" ) term}
    term = factor {( "*" | "/" ) factor}
    factor = number | "(" expr ")" | "-" term

- *Notazione prefissa, o polacca*
    - Es.: `* + 1 2 - 3 2` â‡’ Infissa: `(1 + 2) * (3 - 2)`

code: ebnf

    expr = number | "+" expr expr | "-" expr expr |
                    "*" expr expr | "/" expr expr
    number = digit {digit}
    digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

>

<http://www.ce.unipr.it/brython/?p4_fun_polish.py>

---

title: ðŸ¤” Linguaggi LL(1)

- Sottoclasse dei linguaggi CF
- Ogni produzione relativa a stesso non-terminale (a sx)... <br> genera come primo simbolo un terminale diverso
    - No prefissi comuni, no ricorsione sinistra
- **Recursive descent parser**: analisi sintattica molto semplice ed efficiente
    - Basta â€œspiareâ€ il simbolo di input successivo, per capire con certezza quale produzione applicare

---

title: ðŸ¤” Pumping lemma REG
figure: images/comp/pumping-lemma-3.svg

- Formalmente, `âˆ€ L` regolare...
    * `âˆƒ k t.c. âˆ€ z âˆˆ L, |z| â‰¥ k`
    * `âˆƒ u, v, w, |uv| â‰¤ k, |v| â‰¥ 1 t.c.`
    * `z = uvw, uv^^i^^w âˆˆ L, âˆ€ i â‰¥ 0`
- In ogni stringa abbastanza lunga,
    * c'Ã¨ una parte che si puÃ² ripetere,
    * generando un'altra stringa di `L`
- Uno stesso non-terminale, per un input abbastanza lungo, deve comparire piÃ¹ volte nell'albero sintattico â€¦
    * Un Automa a Stati Finiti (*), per un input abbastanza lungo, torna in uno stato giÃ  visitato â€¦

>

Esempio con `G~~1~~`: `S â†’ b | aA; A â†’ aS`

---

title: ðŸ¤” Pumping lemma CF
figure: images/comp/pumping-lemma-2.svg

- Formalmente, `âˆ€ L` non contestuale...
    * `âˆƒ k t.c. âˆ€ z âˆˆ L, |z| â‰¥ k`
    * `âˆƒ u, v, w, x, y, |vwx| â‰¤ k, |vx| â‰¥ 1 t.c.`
    * `z = uvwxy, uv^^i^^wx^^i^^y âˆˆ L, âˆ€ i â‰¥ 0`
- In ogni stringa abbastanza lunga,
    * ci sono due parti che si possono
    * ripetere assieme, restando in `L`
- Uno stesso non-terminale, per un input abbastanza lungo, deve comparire piÃ¹ volte nell'albero sintattico â€¦

---

title: ðŸ¤” Corollari dei due lemmi

- â‡’ `L = {a^^n^^b^^n^^ : n â‰¥ 0}` non Ã¨ REG
    * Si prende `a^^m^^b^^m^^, con m > k â‡’ |uv| < m`, sono tutte `a`â€¦
- â‡’ `L = {a^^n^^b^^n^^c^^n^^ : n â‰¥ 0}` non Ã¨ CF
    * Si prende `a^^m^^b^^m^^c^^m^^, con m > k â‡’ |vwx| < m`
    * Se `v` ed `x` con piÃ¹ simboli diversi, `uv^^2^^wx^^2^^y` con simboli mescolati
    * Se `v` ed `x` con un solo simbolo, `uv^^2^^wx^^2^^y` con numero diverso di `a`, `b`, `c`
    * In entrambi i casi la nuova stringa `z' âˆ‰ L`

---

title: Linguaggi di programmazione
class: segue dark

---

title: Linguaggi di programmazione

- Notazione formale per definire algoritmi
    - *Algoritmo*: sequenza di istruzioni per risolvere un dato problema in un tempo finito
- Ogni linguaggio Ã¨ caratterizzato da:
    - **Sintassi**
    - **Semantica**

---

title: Sintassi
figure: images/dev/syntax-diagrams.png
class: large-figure

- Insieme di regole formali per scrivere *frasi* ben formate (programmi) in un certo linguaggio
- Spesso analisi a due livelli:
- **Lessico**, tramite *espressioni regolari*
    - Riconosciuti i â€œ*tokens*â€: parole riservate, operatori, variabili, costanti ecc.
- **Struttura**, tramite *grammatiche non contestuali*
    - Backus-Naur Form
    - Extended BNF
    - Diagrammi sintattici

---

title: Semantica

- Attribuisce un **significato** alle frasi (sintatticamente corrette) costruite nel linguaggio
- Una frase puÃ² essere sintatticamente corretta e tuttavia non aver alcun significato
    - Soggetto â€“ predicato â€“ complemento
    - *â€œLa mela mangia il bambinoâ€*
    - *â€œIl bambino mangia la melaâ€*
- Oppure avere un significato diverso da quello previsto...
    - *GREEK_PI = 345*

---

title: Semantica

- **Correttezza sui tipi**
    - Quali tipi di dato possono essere elaborati?
    - Quali operatori applicabili ad ogni dato?
    - Quali regole per definire nuovi tipi e operatori?
- **Semantica operazionale**
    - Qual Ã¨ l'effetto di ogni azione elementare?
    - Qual Ã¨ lâ€™effetto dellâ€™aggregazione delle azioni?
    - CioÃ¨, qual Ã¨ lâ€™effetto dellâ€™esecuzione di un certo programma?

---

title: Linguaggi di basso livello
figure: images/dev/assembly.png
class: large-figure

- PiÃ¹ orientati alla macchina che ai problemi da trattare
- **Linguaggi macchina**: solo operazioni eseguibili direttamente dall'elaboratore
    - Op. molto elementari, diverse per ogni processore, in formato binario
- **Linguaggi assembly**: prima evoluzione, codici binari â†’ mnemonici

---

title: Linguaggi di alto livello

- Introdotti per facilitare la scrittura dei programmi
- Definizione della soluzione in modo intuitivo
- Con una certa **astrazione** rispetto al calcolatore su cui verranno eseguiti
- Devono essere tradotti in linguaggio macchina

---

title: Storia dei linguaggi
class: large-image

![](images/dev/languages-timeline.svg)

>

[Oâ€™Reilly Language Poster](https://www.cs.toronto.edu/~gpenn/csc324/PLhistory.pdf)

[Poster aggiornato](http://www.levenez.com/lang/history.html)

[History of Computer Programming Languages, by A. Ferguson](https://cs.brown.edu/~adf/programming_languages.html)

---

title: The Top 10 (IEEE Spectrum, 2018)
class: large-image

![](images/dev/languages-spectrum-2018.png)

>

<http://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018>

---

title: Paradigmi di sviluppo

- Forniscono la filosofia e la metodologia con cui si scrivono i programmi
- Definiscono il concetto (astratto) di computazione
- Ogni linguaggio consente (o spinge verso) l'adozione di un particolare paradigma
    - Imperativo / procedurale
    - Orientato agli oggetti
    - Scripting (tipizzazione dinamica, principio DRY - Don't Repeat Yourself)
    - Funzionale (funzioni come â€œcittadini di prima classeâ€)
    - Logico (base di conoscenza + regole di inferenza)

---

title: Linguaggi e paradigmi

- **Imperativi / procedurali**
    - Cobol, Fortran, Algol, C, Pascal
- **Orientati agli oggetti**
    - Simula, Smalltalk, Eiffel, Delphi
    - C++, Java, C#, Go, Swift, Rust, ...
- **Scripting**
    - Basic, Perl, PHP, Javascript, Python, VB.NET, Shell
- **Funzionali**
    - Lisp, Scheme, ML, Haskell, Erlang
- **Logici**
    - Prolog...

---

title: Esecuzione dei programmi

- Linguaggio ad alto livello â†’ passi necessari:
    - **Compilazione**, traduzione in linguaggio macchina
    - **Collegamento** con librerie di supporto
    - **Caricamento** in memoria
- Programmi **compilati**: applicati i 3 passi...
    - A tutto il codice; prima dell'esecuzione
- Programmi **interpretati**: applicati i 3 passi...
    - In sequenza, su ogni istruzione; a tempo di esecuzione

![](images/dev/build.svg)

---

title: Compilazione
figure: images/dev/compiler.svg
class: large-figure

- Traduzione da ling. alto livello a ling. macchina
    - Analisi: lessicale, grammaticale, contestuale
    - *Rappresentazione intermedia*: albero sintattico annotato (**AST**)
    - Generazione codice oggetto
- Codice oggetto: non ancora eseguibile
    - Linker, loader

---

title: Albero sintattico
figure: images/dev/ast-euclid.svg
class: large-figure

code: Python

    while b != 0:
        if a > b:
            a = a âˆ’ b
        else:
            b = b âˆ’ a
    return a

Algoritmo di Euclide per MCD

---

title: Collegamento

- Il **linker** collega diversi moduli oggetto
    - Simboli irrisolti â†’ riferimenti esterni
    - Il collegamento puÃ² essere statico o dinamico
- **Collegamento statico**
    - Libreria inclusa nel file oggetto, eseguibile stand-alone
    - Dimensioni maggiori, ma possibile includere solo funzionalitÃ  utilizzate
- **Collegamento dinamico**
    - Librerie condivise da diverse applicazioni
    - Installazione ed aggiornamento unici
    - Caricate in memoria una sola volta

---

title: Caricamento
figure: images/dev/relocation.png

- Il **loader** carica in memoria un programma
    - Risolve indirizzi logici (variabili, salti ecc.)
    - Carica eventuali programmi di supporto (DLL ecc.)
- **Rilocazione statica**: indirizzi logici trasformati in indirizzi assoluti
- **Rilocazione dinamica**: indirizzi logici mantenuti, relativi alla posizione del programma in memoria
    - *Registri base* della CPU (reg. CS, DS e SS su x86): <br> locazione base di codice, dati e stack
    - *Memory Management Unit* in S.O.

---

title: Codice gestito

- Compilazione in **codice intermedio**
    - Bytecode (Java), Common Intermediate Lang. (.NET), â€¦
    - Python: compilato per una macchina virtuale (file .pyc), ma in modo trasparente
- Esecuzione su una **macchina virtuale**
    - Java Virtual Machine, Common Language Runtime, â€¦
    - Emulazione di un certo elaboratore
    - â‡’ Indipendenza da piattaforma fisica
    - Compilazione â€œal voloâ€ (*Just In Time*) in codice nativo
    - Gestione memoria con *garbage collection*

---

title: Sistemi di garbage collection
figure: images/dev/garbage-truck.jpg

- Restituzione automatica della memoria
    - Per oggetti/dati che non servono piÃ¹
- Possibile anche per codice nativo
    - Linguaggio *Go*
    - Estensioni e *â€œsmart pointersâ€* in C++
- Diversi algoritmi
    - *Reference counting*: idea di base, ma cicliâ€¦
    - *Mark & sweep*: parte da riferimenti locali/globali, marca oggetti raggiungibili
    - *Generational garbage collection*: controlla spesso oggetti recenti

---

title: Uso della garbage collection

- Vantaggi
    - Si libera sistematicamente la memoria (*memory leak*)
    - Non si rimuovono dati ancora utili (*dangling pointer*)
    - Dati rilocati per *compattare* la memoria
- Svantaggi
    - Maggiore occupazione del *processore* (~1.3x)
    - Maggiore occupazione di *memoria* (~2x)
    - GC decide autonomamente *quando* operare (problema per *real time*)

>

<https://golang.org/src/runtime/mgc.go>

<https://golang.org/s/go15gcpacing>

---

class: break

- Grammatica equiv. LL(1), ma senza precedenza tra operatori
- Provare a generare `2 + 3 * 3`

code: ebnf

    expr = term {( "+" | "-" | "*" | "/" ) term}
    term = number | "(" expr ")" | "-" term


