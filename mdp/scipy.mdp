title: Python for data analysis
subtitle: NumPy, Pandas, PyPlotLib
figure: images/oop/modules.png

---

title: Python applications

![](images/algo/python-cases.jpg)

- Web, data analysis, scripting, teaching, games, hardware, multiplatform...

---

title: Readability counts
figure: images/algo/perfect-square.svg

code: py

    n = 0
    while n <= 0:
        n = int(input("Positive val? "))

    ans = 1
    while ans * ans < n:
        ans += 1

    if ans * ans == n:
        print("Square root:", ans)
    else:
        print("Not a perfect square")

>

<http://www.ce.unipr.it/brython/?p1_perfect_square.py>

---

title: Functions
figure: images/fun/function.png

- **`def`**, to define a function
- **`return`**, to (optionally) return the result
- Then, you **call** a function to execute it
- Type *annotations* for params and return value are optional and not verified

code: py

    def hypotenuse(leg1: float, leg2: float) -> float:
        hyp = (leg1 ** 2 + leg2 ** 2) ** 0.5
        return hyp

    result = hypotenuse(3, 4)  # 5.0

---

title: List
figure: images/fun/month-list.svg

- **Mutable** sequence of elements
- *Usually* of the same *type*
- Current *length* of a list `x`: `len(x)`
- Elements *enumerated* from `0` to `len(x)-1`

code: py

    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

code: py

    num_days = [31, 28, 31, 30, 31, 30,
                31, 31, 30, 31, 30, 31]

code: py

    results_by_month = [0] * 12  # List repetition

---

title: Elements and slices
figure: images/fun/wile-coyote.png

- **Attention: use valid indices!**
    - But *negative* indices counts from the end

code: py

    n = len(months)            # 12
    months[3]                  # "Apr"
    months[-2]                 # "Nov", same as n - 2

    spring = months[2:5]       # ["Mar", "Apr", "May"]
    quart1 = months[:3]        # ["Jan", "Feb", "Mar"]
    quart4 = months[-3:]       # ["Oct", "Nov", "Dec"]
    whole_year = months[:]     # Copy of the whole list

---

title: Insertion and removal
figure: images/fun/shopping-list.png

code: py

    grocery = ["spam", "egg", "beans"]

    grocery[0] = "sausage"      # replace an element

    grocery.append("bacon")     # add an element to the end
    grocery.pop()               # remove (and return) last element

    grocery.insert(1, "bacon")  # other elements shift
    removed = grocery.pop(1)    # remove (and return) element at index

    if "egg" in grocery:       # True, grocery contains "egg"
        grocery.remove("egg")  # remove an element by value

---

title: Equality and identity

code: py

    a = ["spam", "egg", "beans"]
    b = a[:]         # new list!
    b == a           # True, they contain the same values
    b is a           # False, they are two objects in memory
                     # (try and modify one of them...)
    c = a
    c is a           # True, same object in memory
                     # (try and modify one of them...)

    d = ["sausage", "mushrooms"]
    grocery = c + d  # list concatenation --> new list!

---

title: Strings and lists

- **String**: *immutable* sequence of chars
- **`join`** and **`split`**: from list to string and viceversa

code: py

    txt = "Monty Python's Flying Circus"
    txt[3]    # 't'
    txt[-2]   # 'u'
    txt[6:12] # "Python"
    txt[-6:]  # "Circus"

code: py

    days = ["tue", "thu", "sat"]
    txt = "|".join(days)  # "tue|thu|sat"

code: py

    txt = "mon|wed|fri"
    days = txt.split("|")  # ["mon", "wed", "fri"]

---

title: Tuple

- **Immutable** sequence of values, even of *different type*

code: py

    # Tuple packing
    pt = 5, 6, "red"
    pt[0]  # 5
    pt[1]  # 6
    pt[2]  # "red"

    # multiple assignments, from a tuple
    x, y, colour = pt  # sequence unpacking
    a, b = 3, 4
    a, b = b, a

---

title: Cycles on sequences: for

code: py

    grocery = ["spam", "egg", "bacon", "sausage"]
    for product in grocery:
        print(product)

code: py

    for val in range(0, 5):
        print(val * val, end=" ")  # 0 1 4 9 16

- At each iteration, a different element of `grocery` is assigned to `product`
- A `for` cycle can be used on any kind of sequence: list, string, tuple, range...
- **`range`**: range of consecutive values
    - Lower end *included* (defaults to 0)
    - Upper end *excluded*

---

title: Functions on lists

code: py

    def limit_values(values, max_val):
        # procedure: process data, no direct result
        for i in range(len(values)):
            if values[i] > max_val:
                values[i] = max_val

        # the pythonic way: for i, val in enumerate(values): ...

    def main ():
        data = [5, 4, 2]
        limit_values(data, 4)
        print(data)

    main()

---

title: List comprehension
figure: images/dev/computer-ninja.png

- Terse way to create a list
- Each element: result of an operation on a member of another iterable
- Condition on elements, optional

code: py

    squares = [x ** 2 for x in range(12)]
    # squares = []
    # for x in range(12):
    #    squares.append(x ** 2)

code: py

    even_nums = [str(x) for x in range(12) if (x % 2) == 0]

---

title: Enumerate
figure: images/repr/child-fingers.png

- To couple each value of a sequence to an increasing index
- It generates a sequence of tuples (pairs)
- In `for` cycles, using both value and index

code: py

    >>> grocery = ["spam", "egg", "bacon", "sausage"]
    >>> list(enumerate(grocery))
    [(0, "spam"), (1, "egg"), (2, "bacon"), (3, "sausage")]

code: py

    grocery = ["spam", "egg", "bacon", "sausage"]
    for i, val in enumerate(grocery):
        print(i, val)

>

Results in a list: only (!) to visualize them <br>
Otherwise, Python doesn't generate results immediately (*lazy*)

---

title: Zip
figure: images/fun/zip.png

- Couples elements of two sequences
- It generates a sequence of tuples (pairs)
- The result has the len of the shortest sequence

code: py

    >>> grocery = ["spam", "egg", "bacon", "sausage"]
    >>> quantities = ["100 g", "6 pc", "200 g", "500 g", "too much"]
    >>> list(zip(grocery, quantities))
    [("spam", "100 g"), ("egg", "6 pc"), ("bacon", "200 g"),
    ("sausage", "500 g")]

>

Results in a list: only (!) to visualize them

---

title: Map
figure: images/fun/legomap.png

- Takes a function and a sequence as params
- *Higher order function*
- Applies the function to each value
- Returns the sequence of results

code: py

    >>> from math import sqrt
    >>> values = [0, 1, 2, 3, 4]
    >>> list(map(sqrt, values))
    [0.0, 1.0, 1.4142, 1.7320, 2.0]

code: py

    >>> from math import sqrt
    >>> list(map(sqrt, range(5)))
    [0.0, 1.0, 1.4142, 1.7320, 2.0]

>

Results in a list: only (!) to visualize them

---

title: Sort and reverse

code: py

    >>> grocery = ["spam", "egg", "bacon", "sausage"]
    >>> sorted(grocery)
    ['bacon', 'egg', 'sausage', 'spam']
    >>> sorted(grocery, key=len)  # lengths of elements are compared
    ['egg', 'spam', 'bacon', 'sausage']
    >>> list(reversed(grocery))
    ['sausage', 'bacon', 'egg', 'spam']
    >>> grocery
    ["spam", "egg", "bacon", "sausage"]

code: py

    >>> grocery.sort()     # in-place
    >>> grocery.reverse()  # in-place
    >>> grocery
    ['spam', 'sausage', 'egg', 'bacon']

---

title: Dictionary
figure: images/fun/dictionary.png

- Sometimes called *map* or *associative array*
- Unordered set of key / value pairs
    - Keys are *unique*: like *indices* for lists, to access the associated value
    - They can be sparse `int` or **`str`** (or any other immutable type)

code: py

    >>> tel = {"john": 4098, "terry": 4139}
    >>> tel["john"]
    4098
    >>> tel["graham"] = 4127
    >>> tel
    {"graham": 4127, "terry": 4139, "john": 4098}

>

Try also `list(tel)` and `list(tel.items())`

---

title: Multidim lists
- Lists of lists of ...
    - Access to elements: two or more indices (or *dimensions*)
    - If bidimensional, called *matrices*

code: py

    a = [['A', 'B', 'C', 'D'],
         ['E', 'F', 'G', 'H'],
         ['I', 'L', 'M', 'N']]          # 2D

    b = ['A', 'B', 'C', 'D',
         'E', 'F', 'G', 'H',
         'I', 'L', 'M', 'N']            # 1D

    i = y * cols + x                    # 2D -> 1D

    y = i // cols
    x = i % cols                        # 1D -> 2D

---

title: Sum of columns: matrix

code: py

    matrix = [[2, 4, 3, 8],
              [9, 3, 2, 7],
              [5, 6, 9, 1]]
    rows = len(matrix)
    cols = len(matrix[0])

    for x in range(cols):
        total = 0
        for y in range(rows):
            val = matrix[y][x]
            total += val
        print("Col #", x, "sums to", total)

---

title: List as pseudo-matrix

code: py

    matrix = [2, 4, 3, 8,
              9, 3, 2, 7,
              5, 6, 9, 1]
    rows = 3  # Cannot be guessed from matrix alone
    cols = len(matrix) // rows

    for x in range(cols):
        total = 0
        for y in range(rows):
            val = matrix[y * cols + x]   # 2D -> 1D
            total += val
        print("Col #", x, "sums to", total)

---

title: Matrix with known size

code: py

    matrix = [[' ' for x in range(cols)] for y in range(rows)]
    # all elements are inited as ' ' -- your need may vary

code: py

    matrix = []
    for y in range(rows):
        new_row = []
        for x in range(cols):
            new_row.append(' ')
        matrix.append(new_row)

---

title: Data streams
figure: images/fun/magnetic-tape.png

- **Stream**: abstraction for information stream
    - Reading and writing information on *any* I/O device (*file, and more*)
- **Text file**
    - Various encodings (*UTF-8*, or other)
    - Automatic conversions, e.g. `"\n"` → `"\r\n"`
- **Binary file**
    - Precise I/O, bytes are not converted
    - Any file... also a text file!

---

title: Writing on file

- `open` function to access a file (text, by default)
    - Write or read mode: `"w"`, o `"r"` (def.)
- Writing to file: `print` funtion, or `write` method
- `with` section: at the end the file is closed (also in case of error)

code: py

    with open("some_file.txt", "w") as f1:
        f1.write("First line\n")   # explicit newline
        f1.write("Second line\n")  # continue writing here...

    with open("other_file.txt", "w") as f2:
        for x in range(10):
            print(x, x ** 2, file=f2)

---

title: Reading from file

code: py

    with open("some_file.txt", "r") as f1:
        first_line = f1.readline()
        second_line = f1.readline()
        # both strings contain '\n' at the end
        # at end of file, an empty string is read

    with open("other_file.txt", "r") as f2:
        whole_text = f2.read()
        # do stg with whole_text

    with open("last_file.txt", "r") as f3:
        for line in f3:
            # line contains '\n' at the end
            # strip() removes withespaces at both ends
            print(line.strip(), ':', len(line))

---

title: Basic CSV files

code: py

    matrix = []
    cols, rows = 0, 0

    with open('matrix.csv', 'r') as file1:
        for line in file1:
            splitted = line.split(',')
            vals = [int(i) for i in splitted]
            matrix.append(vals)
            ## matrix += vals  # for a simple list (ex. 4.5)

            if cols == 0:
                cols = len(vals)
            rows += 1

---

title: CSV module

code: py

    import csv
    matrix = []
    with open('some.csv', newline='') as f:
        reader = csv.reader(f)
        for row in reader:
            matrix.append(row)
    print(matrix)

    with open('some.csv', 'w', newline='') as f:
        writer = csv.writer(f)
        for row in matrix
            writer.writerow(row)

---

title: I/O for strings and console

- Strings as streams: `io.StringIO`
- Console as stream: `sys.stdin`, `sys.stdout`, `sys.stderr`

code: py

    import io, sys

    with io.StringIO() as output:
        output.write("First line.\n")
        print("Second line.", file=output)
        # Retrieve stream contents, i.e. "First line.\nSecond line.\n"
        contents = output.getvalue()
        sys.stdout.write(contents)

code: py

    for line in sys.stdin:  # CTRL-D (Lin) or CTRL-Z (Win) to end the input
        print(len(line))    # notice '\n' at the end

---

title: Errors on file
figure: images/fun/garbled-tape.png

- **Exceptions**: to handle unexpected cases separately
    - Error inside `try`: esecution is interrupted immediately
    - `except` section is executed, to handle the specific type of error (multiple `except` sections are allowed)
    - A `with` section assures the file is closed

code: py

    try:
        with open("other_file.txt", "r") as f:
            whole_text = f.read()
            # do stg with whole_text
    except IOError as err:
        print("Oh, my!")

---

title: Scientific Python
class: segue dark

---

title: Lists in memory
class: large-image

![](images/scipy/python-list-list.svg)

---

title: Number crunching in Python

- Inefficient **memory** layout
    - Multiple *dereferencing* steps
    - Each value is a “*fat*” object, an `int` takes dozens of bytes
    - Values are *not contiguous*, not cache friendly
- `a + b` executed as:
    - `a.__add__(b)`, or...
    - `b.__radd__(a)`, if `__add__` not found
- Python is **dynamic**
    - *Monkey patching*
    - Any method, special or not, can be changed or *decorated* at any time
    - Lookup at each call

---

title: Method lookup

- In general, methods are handled as attributes
    - Complex lookup in multiple dictionaries
    - Starts with `a.__getattribute__("something")`
    - An *instance* has its own methods
    - A *class* has its own methods
    - A *base class* has its own methods
    - A *metaclass* may also alter the lookup
- “Special methods” are... *special*
    - Cannot be set for a single instance
    - Faster lookup
    - Still possibly going through multiple dictionaries

---

title: Anaconda
figure: images/dev/jupyter-notebook.png
class: large-figure

- Popular open-source distribution of Python: <http://anaconda.com>
- Based on the Scipy.org ecosystem
- Modules for *data analysis* and *machine learning*
- Conda: package management
- Numba: JIT compiler, code vectorization
- Jupyter Notebook: browser-based REPL
    - `$ jupyter notebook`

---

title: Virtual environments

- Standard Python provides *virtual environments*
- To install different modules for different projects
- Ex.: *create* `myenv` env., *activate* it, *install* some modules

code: Shell

    $ python3 -m venv myenv
    $ source myenv/bin/activate
    $ pip install numpy

- First command creates new folder, with a copy of CPython
- To change to another env, *deactivate* the current one
    - To delete an env, delete its folder
- On Windows, scripts are in the `Script` folder
    - `sci-env\Scripts\activate.bat`

---

title: Anaconda environments

code: Shell

    $ conda create --name myenv
    $ conda install -n myenv numpy
    $ conda activate myenv
    ...
    $ conda deactivate myenv
    $ conda remove --name myenv --all

- It is also possible to specify a Python version
    - `conda create -n myenv python=3.4`

---

title: NumPy
class: segue dark

---

title: NumPy module
figure: images/scipy/numpy-mem.png
figcaption: np.zeros(shape=(2, 5), dtype=np.int32)
class: large-figure

- Numeric, 1995; NumPy, 2006
- **N-dimensional array**
    - Homogeneously typed
    - Efficient memory layout (~ C)
- Efficient **algorithms**
    - Impl. Fortran, C/C++, Cython
    - Functionality comparable to basic *MATLAB*
- Base of *SciPy* ecosystem
    - MatPlotLib, SymPy, Pandas, Scikit-learn, Scikit-image
- Also used for *images*
    - In PyGame, Python bindings of OpenCV, etc.

---

title: NumPy arrays

code: py

    >>> import numpy as np
    >>> a = np.array([2, 3, 4])
    >>> a
    array([2, 3, 4])
    >>> a.dtype
    dtype('int64')

code: py

    >>> b = np.array([1.2, 3.5, 5.1])
    >>> b.dtype
    dtype('float64')

code: py

    c = np.array([[1, 2], [3, 4]], dtype=np.float64)
    >>> c
    array([[1., 2.],
           [3., 4.]])

---

title: Zeros, ones, ranges

code: py

    >>> np.zeros(4)
    array([0, 0, 0, 0])

    >>> np.ones((2, 3), dtype=np.int16)  # dtype can also be specified
    array([[[1, 1, 1],
            [1, 1, 1]], dtype=int16)

    >>> np.empty((2, 3))  # uninitialized, output may vary
    array([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],
           [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]])

    >>> np.arange(10, 30, 5)  # from 10, to 30, step 5
    array([10, 15, 20, 25])

    >>> np.linspace(0, 2, 5)  # 5 numbers from 0 to 2
    array([0, 0.5, 1, 1.5, 2])

---

title: Reshape and resize

- **Shape**: the number of elements along each axis

code: py

    >>> a = np.arange(12)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    >>> a = a.reshape(3, 4)  # a new array
    >>> a
    array([[0, 1, 2, 3],
           [4, 5, 6, 7],
           [8, 9, 10, 11]])
    >>> a.shape
    (3, 4)

    >>> a.resize(2, 6)  # modifies the array itself
    >>> a
    array([[0, 1, 2, 3, 4, 5],
           [6, 7, 8, 9, 10, 11]])

---

title: Random

code: py

    >>> np.random.randn(2, 3)  # normal Gaussian, mean=0, variance=1
    array([[-0.452, -1.295, 0.379],
           [1.134, -0.554, -1.007]])

    >>> np.random.rand(2, 3)  # uniform in [0.0, 1.0)
    array([[0.152, 0.002, 0.219],
           [0.668, 0.840, 0.236]])

    >>> np.random.randint(0, 10, (2, 3))  # discrete uniform in [0, 10)
    array([[1, 9, 3],
           [3, 8, 9]])

>

<https://docs.scipy.org/doc/numpy-1.16.0/reference/routines.random.html>

---

title: Shuffle and choice

code: py

    >>> a = np.arange(6)
    >>> np.random.shuffle(a)  # modifies the array itself
    array([5, 3, 2, 4, 1, 0]])

    >>> np.random.choice(["one", "two"], (2, 3))
    >>> array([['two', 'one', 'one'],
       ['two', 'two', 'one']], dtype='<U3')

---

title: Exercise - Memory game
figure: images/misc/memory.png

- `np.tile(a, reps)` repeats the whole `a`
- `np.repeat(a, reps)` repeats each element of `a`
    - There's also a method of `ndarray`
- *Exercise*: create a matrix with couples
    - Given `n = rows * cols`
    - `n / 2` different values, each repeated twice
    - But random positions

---

title: Vector data

- Each sample encoded as a 1D vector
- A *batch* of data encoded as a **2D tensor**
    - First axis: samples
    - Second axis: features
- Example: *actuarial dataset of people*
    - Each person has 3 features: age, ZIP code, income
    - Dataset of 100,000 people has shape (100000, 3)
- Example: *dataset of text documents*
    - Each document encoded as a vector of 20,000 values
    - Occurrences of each word, from a dict. of 20,000
    - Dataset of 500 documents: shape `(500, 20000)`

---

title: Timeseries or sequence data
figure: images/scipy/tensor-timeseries.png
class: large-figure

- Each sample encoded as a 2D tensor: time sequence of vectors
- A *batch* of data encoded as a **3D tensor**
    - First axis: samples
    - Second axis: always the time axis (#1), by convention
- Example: *dataset of stock prices*
    - Each minute encoded as a vector of 3 values
    - Current price of stock, highest and lowest price in the past minute
    - Each sample, an entire day of trading: shape `(390, 3)`
    - 250 days’ worth of data: shape `(250, 390, 3)`

---

title: Image data
figure: images/scipy/tensor-image.png
class: large-figure

- By convention, image tensors are always 3D
    - Height, width, color depth
    - 1D color channel for grayscale images
- A *batch* of data encoded as **4D tensor**
    - 128 grayscale 256x256 images: shape `(128, 256, 256, 1)`
    - 128 color images: shape `(128, 256, 256, 3)`
- Two conventions
    - *Channels-last* (TensorFlow)
    - *Channels-first* (Theano): samples, color depth, height, width

---

title: Video data

- Each frame is a color image: 3D tensor
- Each video is a sequence of frames: 4D tensor
- A *batch* of data encoded as **5D tensor**
    - Samples, frames, height, width, color depth
- Example: *dataset of YouTube videos*
    - 144×256 video clip with 240 frames
    - 60-second video, sampled at 4 fps
    - A batch of four such video clips: shape `(4, 240, 144, 256, 3)`
    - If `dtype` is `float32`: 405 MB

---

title: NumPy internals

- NumPy arrays consist of two major components
- Raw array data, *data buffer*
    - Contiguous (and fixed) block of memory
    - As arrays in C or Fortran
- Information about data, *metadata*
    - Start of data within buffer (offset)
    - Number of dimensions, size of each dimension
    - Separation between elements for each dimension, *stride*
    - Interpretation of data buffer, *dtype*
    - C-order (row major, default) or Fortran-order (column major)

---

title: Multiple array views

- Possible to create a new array metadata object
    - Same data buffer, shared
    - New view, interpretation of that data buffer
- Slice, transpose, reshape etc.: data doesn't move
    - Different array object (metadata)
    - Different shape, offset, byte order, strides, etc.
    - But same shared data buffer
- New and independent array: `copy()` method

---

title: Data type objects

- `dtype`: interpretation of the array buffer
    - *No rearrangement* of the data!
- Predefined types (i.e. `np.int32`), or string definitions
    - Examples: `"i2"`, `"f4"`, `"U10"` (10 chars), `"O"` (Py obj)
    - `"<"` little endian, `">"` big endian

code: py

    a = np.array([1, 2, 3, 4], dtype="<i2")
    a  # array([1, 2, 3, 4], dtype=int16)
    a.data.tobytes()  # b'\x01\x00\x02\x00\x03\x00\x04\x00'
    a.dtype = ">i2"
    a  # array([256, 512, 768, 1024], dtype=int16)
    a.dtype = "f2, 2i1"
    a  # array([(6.e-08, [2, 0]), (2.e-07, [4, 0])],
       #       dtype=[('f0', '<i2'), ('f1', 'i1', (2,))])

---

title: Strides
class: large-image

![](images/scipy/strides.png)

code: py

    a = np.zeros(shape=(3, 3), dtype=np.int32)
    a.strides  # (12, 4)

- Problem: byte-address of cell @ `(y, x)`?
    - `data + y * 12 + x * 4`

---

title: Shape manipulation

code: py

    >>> a = np.array([[2, 8, 0],
                      [4, 5, 1]], dtype=np.int64)
    >>> a.strides
    (24, 8)
    >>> b = a.reshape(3, 2)  # new view, different shape
    >>> b
    array([[2, 8],
           [0, 4],
           [5, 1]])
    >>> b.strides
    (16, 8)
    >>> b.flatten()
    array([2, 8, 0, 4, 5, 1])

>

`flatten` has optional param for `order`: "K" (as in memory), or "C", or "F"

---

title: Transposition

code: py

    >>> a = np.array([[2, 8, 0],
                      [4, 5, 1]], dtype=np.int64)
    >>> a.shape, a.strides
    ((2, 3), (24, 8))
    >>> a.T  # transposed view, same as a.transpose()
    array([[2, 4],
           [8, 5],
           [0, 1]])
    >>> a.T.shape, a.T.strides
    ((3, 2), (8, 24))
    >>> a.T.flatten()
    array([2, 4, 8, 5, 0, 1])
    >>> a.T.flatten("K")  # real order of data in memory!
    array([2, 8, 0, 4, 5, 1])

---

title: Row or column-major
figure: images/scipy/row-col-major.svg

- C-order, row-major: a row is contiguous
- F-order, col-major: a col is contiguous
- Strides: *indexing is invariant* wrt ordering
- But *cache efficiency* may be different

code: py

    a = np.array([[1, 2], [3, 4]], order="C", dtype="i1")
    a  # array([[1, 2], [3, 4]], dtype=int8)
    a.strides  # (2, 1)
    a.flatten("K")  # array([1, 2, 3, 4], dtype=int8)

code: py

    a = np.array([[1, 2], [3, 4]], order="F", dtype="i1")
    a  # array([[1, 2], [3, 4]], dtype=int8)
    a.strides  # (1, 2)
    a.flatten("K")  # array([1, 3, 2, 4], dtype=int8)

---

title: Elementwise operations

- Most operators apply elementwise
- A new array holds the result
- Some ops act *in place*: `+=`, `*=`, ...

code: py

    >>> a = np.array([20, 30, 40, 50])
    >>> a < 35
    array([True, True, False, False])

    >>> b = np.arange(4)
    >>> b ** 2
    array([0, 1, 4, 9])
    >>> a - b
    array([20, 29, 38, 47])

---

title: Matrix multiplication
figure: images/scipy/matrix-mult.svg

code: py

    >>> A = np.array([[1, 1],
    ...               [0, 1]])
    >>> B = np.array([[2, 0],
    ...               [3, 4]])
    >>> A * B                 # elementwise product
    array([[2, 0],
           [0, 4]])
    >>> A @ B                 # matrix product (Py3.5)
    array([[5, 4],
           [3, 4]])
    >>> A.dot(B)              # another matrix product
    array([[5, 4],
           [3, 4]])

---

title: Aggregate functions

- By default, array handled as a list of numbers, regardless of shape

code: py

    >>> b = np.arange(12).reshape(3, 4)
    >>> b
    array([[0, 1, 2, 3],
           [4, 5, 6, 7],
           [8, 9, 10, 11]])
    >>> b.sum()              # guess also min and max
    66
    >>> b.sum(axis=1)        # sum of each row
    array([6, 22, 38])
    >>> b / b.max(axis=0)    # norm each column
    array([[0., 0.11, 0.2, 0.27],
           [0.5, 0.55, 0.6, 0.63],
           [1., 1., 1., 1.  ]])

---

title: Universal functions

- Math funcs provided as “*universal functions*” (*ufunc*)
    - Operate elementwise and return an array
    - `sin`, `cos`, `exp` etc.

code: py

    >>> A = np.linspace(0, np.pi/2, 4)
    >>> np.sin(A)
    array([0, 0.5, 0.8660254, 1])

code: py

    >>> B = np.arange(3)
    >>> B
    array([0, 1, 2])
    >>> np.exp(B)
    array([1, 2.71828183, 7.3890561])
    >>> np.sqrt(B)
    array([0, 1, 1.41421356])

---

title: Indexing and slicing

- Multidimensional arrays: one index per axis
    - Indices are given in a tuple separated by commas

code: py

    >>> def f(y, x): return 10 * y + x
    >>> b = np.fromfunction(f, (3, 4), dtype=int)
    >>> b
    array([[0, 1, 2, 3],
           [10, 11, 12, 13],
           [20, 21, 22, 23]])
    >>> b[2, 3]
    23
    >>> b[:, 1]  # each row in the second column of b
    array([1, 11, 21])
    >>> b[1:3, 0:2]
    array([[10, 11],
           [20, 21]])

---

title: Dots

- Dots (`...`) represent as many colons as needed
    - ... to produce a complete indexing tuple

code: py

    >>> c = np.array( [[[0, 1, 2],       # a 3D array
                        [10, 12, 13]],
                       [[100,101,102],
                        [110,112,113]]])
    >>> c.shape
    (2, 2, 3)
    >>> c[1,...]  # same as c[1,:,:] or c[1]
    array([[100, 101, 102],
           [110, 112, 113]])
    >>> c[...,2]  # same as c[:,:,2]
    array([[2, 13],
           [102, 113]])

---

title: Iterating

- Iterating over a multidim. array: wrt the first axis
- The `flat` attribute is an iterator over all the elements

code: py

    >>> b
    array([[0, 1, 2, 3],
           [10, 11, 12, 13],
           [20, 21, 22, 23]])
    >>> for row in b: print(row)
    [0 1 2 3]
    [10 11 12 13]
    [20 21 22 23]
    >>> for val in b.flat: print(val, end=" ")
    0 1 2 3 10 11 12 13 20 21 22 23

---

title: Stacking

code: py

    >>> a = np. array([[8, 8],
                       [0, 0]])
    >>> b = np.array([[1, 8],
                      [0, 4]])
    >>> np.vstack((a, b))
    array([[8, 8],
           [0, 0],
           [1, 8],
           [0, 4]])
    >>> np.hstack((a, b))
    array([[8, 8, 1, 8],
           [0, 0, 0, 4]])

---

title: Splitting into several arrays

- `hsplit` splits an array along its horizontal axis
    - Specify num of equally shaped arrays to return, or...
    - Specifying columns where division should occur
- `vsplit` works on the vertical axis

code: py

    >>> a = np.array([[9, 5, 6, 3, 6, 8, 0, 7, 9],
                      [1, 4, 9, 2, 2, 1, 0, 6, 2]])
    >>> np.hsplit(a, 3)   # Split a into 3
    [array([[9, 5, 6], [1, 4, 9]]),
     array([[3, 6, 8], [2, 2, 1]]),
     array([[0, 7, 9], [0, 6, 2]])]
    >>> np.hsplit(a, (3, 4))   # Split after 3rd and 4th column
    [array([[9, 5, 6], [1, 4, 9]]),
     array([[3], [2]]),
     array([[6, 8, 0, 7, 9], [2, 1, 0, 6, 2]])]

---

title: Linear algebra

code: py

    >>> a = np.array([[1.0, 2.0],
                      [3.0, 4.0]])
    >>> np.linalg.det(a)
    -2.0
    >>> b = np.linalg.inv(a)
    >>> b
    array([[-2., 1. ],
           [1.5, -0.5]])
    >>> a @ b
    array([[1., 0.],
           [0., 1.]])
    >>> np.eye(2)  # unit 2x2 matrix; "eye" represents "I"
    array([[1, 0],
           [0, 1]])

---

title: Exercise - Fair tickets
figure: images/misc/fair-tickets.jpg
class: large-figure

- Cost of a ticket for a fair
    - 4.00€ for adults
    - 1,50€ for children
- At the end of the day
    - 2200 visitors have entered (*b1*)
    - 5050€ have been collected (*b2*)
- How many adults (*x1*) and how many children (*x2*) have entered?
    - Linear system: `a @ x = b`
    - Solve with matrix operations

---

title: Determinant and autovectors

code: py

    >>> a = np.array([[1.0, 2.0],
                      [3.0, 4.0]])
    >>> w, v = np.linalg.eig(a)
    >>> w  # eigenvalues
    array([-0.37228132, 5.37228132])
    >>> np.linalg.det(w[0] * np.eye(2) - a)  # det(λI − A) = 0
    0.0
    >>> v.T  # eigenvectors, normalized but transposed (!)
    array([[-0.82456484, 0.56576746],
           [-0.41597356, -0.90937671]])
    >>> sum(v.T[0] ** 2)  # magnitude = 1
    1.0
    >>> (w[0] * np.eye(2) - a) @ v.T[0]  # (λI − A)v = 0
    array([0, 0])

---

title: Solve a linear system

- Linear system
    - `a @ x = b`
    - `inv(a) @ a @ x = inv(a) @ b`
    - `x = inv(a) @ b`

code: py

    >>> a = np.array([[1., 1.],
                      [4., 1.5]])
    >>> b = np.array([2200., 5050.])
    >>> np.linalg.inv(a) @ b  # b: 1D, as column vector
    array([700., 1500.])
    >>> np.linalg.solve(a, b)
    array([700., 1500.])

---

title: Pandas
class: segue dark

---

title: Pandas

- Library of data *structures* and data *analysis tools*
    - High-performance, easy-to-use
    - Use cases are similar to R-lang
- Often used with *Jupyter Notebook*, Web app to create and share documents
    - Fragments of code in various languages
    - Can be executed and modified
    - Equations, visualizations, text
    - Useful for data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, etc.

---

title: Creating a DataFrame
figure: images/misc/sidewinder.jpg

- **DataFrame** : ~ Excel worksheet
- *Values* as `np.array` + *indexes* for rows and cols

code: py

    >>> import pandas as pd
    >>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],
                          index=['cobra', 'viper', 'sidewinder'],
                          columns=['max_speed', 'shield'])
    >>> df
                max_speed  shield
    cobra               1       2
    viper               4       5
    sidewinder          7       8

---

title: Data summary

- Show top or bottom rows: `df.head()`, `df.tail()`
- Access values, index, columns: `df.values`, `df.index`, `df.columns`
- Transposed view: `df.T`

code: py

    >>> df.describe()  # show static summary
           max_speed  shield
    count        3.0     3.0
    mean         4.0     5.0
    std          3.0     3.0
    min          1.0     2.0
    25%          2.5     3.5
    50%          4.0     5.0
    75%          5.5     6.5
    max          7.0     8.0

---

title: Projection of columns

- Each column is a **`Series`**
    - *Values* as `np.array` + *name* + *index*

code: py

    >>> df['max_speed']  # or simply df.max_speed
    cobra         1
    viper         4
    sidewinder    7
    Name: max_speed, dtype: int64

    >>> df[['max_speed', 'shield']]
                max_speed  shield
    cobra               1       2
    viper               4       5
    sidewinder          7       8

---

title: Selection of rows

- With brackets, a slice of rows can be selected
    - Provide both start and stop, not a single position or label
    - With labels, *the stop label is included!*

code: py

    >>> df[1:3]
                max_speed  shield
    viper               4       5
    sidewinder          7       8

    >>> df['viper':'sidewinder']
                max_speed  shield
    viper               4       5
    sidewinder          7       8

---

title: Slicing in both axis

- Slicing by labels (*the stop label is included!*)

code: py

    >>> df.loc['viper':'sidewinder', 'max_speed':'shield']
                max_speed  shield
    viper               4       5
    sidewinder          7       8

- Slicing by positions (*the stop position is not included!*)

code: py

    >>> df.iloc[1:3, 0:2]
                max_speed  shield
    viper               4       5
    sidewinder          7       8

---

title: Boolean filtering

code: py

    >>> df.loc[[False, False, True]]
                max_speed  shield
    sidewinder          7       8

    >>> df.loc[df['shield'] > 6]
                max_speed  shield
    sidewinder          7       8

    >>> df.loc[df['shield'] > 6, 'max_speed']
                max_speed
    sidewinder          7

---

title: Setting

code: py

    >>> df2 = df.copy()
    >>> df2.loc[['viper', 'sidewinder'], ['shield']] = 50
    >>> df2
                max_speed  shield
    cobra               1       2
    viper               4      50
    sidewinder          7      50

---

title: Adding a column, is-in

code: py

    >>> df2 = df.copy()
    >>> df2['label'] = ['one','two','three']
    >>> df2
                max_speed  shield  label
    cobra               1       2    one
    viper               4       5    two
    sidewinder          7       8  three

    >>> df2[df2['label'].isin(['one','two'])]
                max_speed  shield  label
    cobra               1       2    one
    viper               4       5    two

---

title: Sorting by value or index

code: py

    >>> df.sort_values(by='shield')  # asc values of shield
                max_speed  shield
    cobra               1       2
    viper               4       5
    sidewinder          7       8

    >>> df.sort_index(axis=1, ascending=False)  # desc column names
                shield  max_speed
    cobra            2          1
    viper            5          4
    sidewinder       8          7

---

title: DataFrame from a dict, csv, xlsx

code: py

    df1 = pd.DataFrame({
                'shield': np.array([2, 5, 8], dtype='int32'),
                'max_speed': np.array([1, 4, 7], dtype='int32') },
            index=['cobra', 'viper', 'sidewinder'])

    df2 = pd.read_csv('data.csv')
    df2.to_csv('data.csv')

    df3 = pd.read_excel('data.xlsx')
    df3.to_excel('data.xlsx')

---

title: Histogramming

code: py

    >>> s = pd.Series(np.random.randint(6, size=10))  # [0, 6)
    >>> s
    0    4
    1    2
    2    1
    3    2
    ...
    dtype: int64
    >>> s.value_counts()  # result is also a Series
    4    5
    6    2
    2    2
    1    1
    dtype: int64

---

title: Concat and merge

- Take multiple pandas and put them together
- `concat()`: one dataframe or series below the other
    - `join`: one of `'outer'`, `'inner'`
    - Default is `'outer'`, return all columns
- `merge()`: rows are joined when they have the same *key*
    - `how`: one of `'left'`, `'right'`, `'outer'`, `'inner'`
    - Default is `inner`: *key* must occurr in *both* frames

code: py

    >>> left = pd.DataFrame({'key': ['foo', 'bar'], 'lval': [1, 2]})
    >>> right = pd.DataFrame({'key': ['foo', 'bar'], 'rval': [4, 5]})
    >>> pd.merge(left, right, on='key')
       key  lval  rval
    0  foo     1     4
    1  bar     2     5

---

title: Group-by

- Split data into groups based on some criteria
- Apply a function to each group independently
- Combine the results into a data structure

code: py

    >>> df = pd.DataFrame({'A' : ['foo', 'bar', 'foo', 'bar',
                                  'foo', 'bar', 'foo', 'foo'],
                           'B' : ['one', 'one', 'two', 'three',
                                  'two', 'two', 'one', 'three'],
                           'C' : np.random.randn(8),
                           'D' : np.random.randn(8)})
    >>> df.groupby('A').sum()  # only numeric data
                C        D
    A
    bar -2.802588  2.42611
    foo  3.146492 -0.63958

---

title: Pivot table

- Transform the dataframe
    - Using values as new rows and columns titles
    - Cells contain *averages*, i.e., `aggfunc=np.mean`

code: py

    >>> df = pd.DataFrame({
            'A' : ['one', 'one', 'two', 'three'] * 3,
            'B' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2,
            'C' : np.random.randn(12)})
    >>> pd.pivot_table(df, index='A', columns='B', values='C')
    B           bar       foo
    A
    one    0.463952  0.419066
    three -0.660418  0.991739
    two    0.091446  0.236650

---

title: MatPlotLib
class: segue dark

---

title: Basic plots
figure: images/scipy/pyplot-1.png images/scipy/pyplot-2.png
class: large-figure

code: py

    import matplotlib.pyplot as plt
    plt.plot([1, 2, 3, 4])
    plt.ylabel('some numbers')
    plt.show()

code: py

    # plot x versus y
    plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
    plt.show()

>

[matplotlib.org](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot)

---

title: Formatting the plot
figure: images/scipy/pyplot-3.png
class: large-figure

code: py

    plt.plot([1, 2, 3, 4], [1, 4, 9, 16], 'ro')
    plt.axis((0, 6, 0, 20)) # xmin, xmax, ymin, ymax
    plt.show()

code: py

    # example format strings
    'b'    # blue markers with default shape
    'ro'   # red circles
    'g-'   # green solid line
    '--'   # dashed line with default color
    'k^:'  # black triangle_up markers connected by a dotted line

>

<https://www.mathworks.com/help/matlab/ref/linespec.html>

---

title: Plotting NumPy arrays
figure: images/scipy/pyplot-4.png
class: large-figure

code: py

    # evenly sampled time at 200ms steps
    t = np.arange(0, 5, 0.2)

    # red dashes, blue squares and green triangles
    plt.plot(t, t, 'r--',
             t, t**2, 'bs',
             t, t**3, 'g^')
    plt.show()

>

To use a logarithmic scale: `plt.yscale('log')`

---

title: Plotting data from dict
figure: images/scipy/pyplot-5.png
class: large-figure

code: py

    data = {'a': np.arange(50),
            'c': np.random.randint(0, 20, 50),
            'd': np.abs(np.random.randn(50)) * 100}
    data['b'] = data['a'] + 10 * np.random.randn(50)

    plt.scatter('a', 'b', c='c', s='d', data=data)
    plt.xlabel('entry a')
    plt.ylabel('entry b')
    plt.show()

    # s for size, c for color
    # 'c': one int out of 20 (index for a color-map)

---

title: Subplots in row
figure: images/scipy/pyplot-6.png
class: large-figure

code: py

    names = ['group_a', 'group_b', 'group_c']
    values = [1, 10, 100]

    plt.figure(1, figsize=(9, 3))  # inches

    plt.subplot(131)  # rows, cols, index
    plt.bar(names, values)
    plt.subplot(132)  # rows, cols, index
    plt.scatter(names, values)
    plt.subplot(133)  # rows, cols, index
    plt.plot(names, values)
    plt.suptitle('Categorical Plotting')
    plt.show()

---

title: Subplots in column
figure: images/scipy/pyplot-7.png
class: large-figure

code: py

    def f(t):
        return np.exp(-t) * np.cos(2*np.pi*t)

    t1 = np.arange(0.0, 5.0, 0.1)
    t2 = np.arange(0.0, 5.0, 0.02)

    plt.subplot(211)  # rows, cols, index
    plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')

    plt.subplot(212)  # rows, cols, index
    plt.plot(t2, np.cos(2*np.pi*t2), 'r--')
    plt.show()

---

title: Histogram and text
figure: images/scipy/pyplot-8.png
class: large-figure

code: py

    mu, sigma = 100, 15
    x = mu + sigma * np.random.randn(10000)

    # histogram of data, with 50 “bins”
    plt.hist(x, 50, facecolor='g')

    plt.xlabel('Smarts')
    plt.ylabel('Probability')
    plt.title('Histogram of IQ')
    plt.text(60, .025, r'$\mu=100,\ \sigma=15$')
    plt.grid(True, alpha=0.75)
    plt.show()

---

title: Seaborn histogram
figure: images/scipy/sns-distplot.png
class: large-figure

- **Seaborn**: high level data visualization library based on *matplotlib*
- `distplot`: histogram + *kde (kernel density estimation)*
    - Optional params: `bins` (`int`),<br/> `kde`, `rug`, `hist` (`bool`)

code: py

    import numpy as np
    import matplotlib.pyplot as plt
    import seaborn as sns

    x = np.random.randn(100)
    sns.distplot(x)  # try rug=True, kde=False
    plt.show()

---

title: Linear regression and correlation
figure: images/scipy/sns-regplot.png
class: large-figure

- Best fitting linear model
    - Minimize the *mean squared error*
    - Translucent bands: confidence interval
- *Pearson's r*, correlation coeff.: [-1, 1]

code: py

    from scipy import stats

    tips = sns.load_dataset("tips")
    sns.regplot(tips.total_bill, tips.tip)
    plt.show()

    x, y = tips.total_bill, tips.tip
    ## r_value, p_value = stats.pearsonr(x, y)
    slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)

---

title: Fitting data wrt a model

- *1.* Define the model as a parametric function
- *2.* Find optimal parameters: `curve_fit`
- *3.* Measure the error

code: py

    from scipy.optimize import curve_fit
    ## from sklearn.metrics import mean_squared_error
    ## from sklearn.metrics import mean_squared_log_error

    x = np.arange(5); y_true = x ** 2  # data
    def f(x, a, b): return a * x + b   # model

    popt, _ = curve_fit(f, x, y_true)  # [4, -2]
    y_pred = f(x, *popt)  # arguments unpacking
    mse = ((y_true - y_pred) ** 2).mean()  # 2.8

---

title: Comparing models
figure: images/scipy/curve-fit.png
class: large-figure

code: py

    x = np.arange(5); y_true = x ** 2
    plt.plot(x, y_true, "ro")

    def f1(x, a, b): return a * x + b
    def f2(x, a, b, c): return a * b ** x + c
    models = [(f1, "b--"), (f2, "g--")]  # or lambdas

    for f, style in models:
        popt, _ = curve_fit(f, x, y_true)
        y_pred = f(x, *popt)  # arguments unpacking
        mse = ((y_true - y_pred) ** 2).mean()
        print(mse, popt)
        plt.plot(x, y_pred, style)

    plt.show()

---

title: Example: students' questionnaires
figure: images/dii/quiz.png
class: large-figure

- Students' answers to questionnaires about courses
- Data transformation to evaluate marks
- Distribution of marks and density plots
- Use of multiple figures

>

<https://www.dropbox.com/s/bfunquwvcg8mv09/report-2016-2017.csv?dl=1><br/>
<https://www.dropbox.com/s/bj3rm90083d2rqz/report-2017-2018.csv?dl=1><br/>
<https://www.dropbox.com/s/shlodh26c06eaib/questionari.odp?dl=1><br/>
<https://www.dropbox.com/s/w3yany4d2mzn4x0/questionario-stage-2018.xlsx?dl=1><br/>
<https://www.dropbox.com/s/9hcpjqij1vcspjx/gilet-jaunes.zip?dl=1>
