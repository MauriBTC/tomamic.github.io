title: Sistema binario
subtitle: Introduzione all'informatica
figure: images/repr/binary-fingers.svg

---

title: Analogico e digitale
figure: images/repr/analog-clock.png images/repr/digital-clock.png

- Una grandezza (fisica o astratta) puÃ² essere rappresentata in due forme
    - **Analogica**: insieme di valori **continuo** (*denso e â€œsenza buchiâ€*)
    - **Digitale** (o numerica): insieme di valori **discreto** (*tutti i punti sono isolati*)

---

title: Approssimazione discreta

- Alcune informazioni sono intrinsecamente discrete
    - Informazioni â€œartificialiâ€, es. un testo scritto
    - Scala atomica o subatomica â€¦
- Molte grandezze fisiche hanno forma continua
    - Per loro elaborazione al calcolatore: rappresentazione digitale
    - *Approssimazione* del valore analogico
    - Errore dipende dalla precisione della rappresentazione digitale scelta

---

title: Codice

- Sistema basato su simboli, che permette la rappresentazione dellâ€™informazione
- *Simbolo*: elemento atomico
- *Alfabeto*: insieme dei simboli possibili (`A`)
- *CardinalitÃ * del codice: numero di simboli dellâ€™alfabeto
- *Stringa*: sequenza di simboli (`s âˆˆ A*`)
- *Linguaggio*: insieme stringhe ben formate (`L âŠ† A*`)

---

title: Codice posizionale
figure: images/repr/child-fingers.png

- Un numero naturale puÃ² essere rappresentato con una notazione posizionale
- `N = c~~0~~ Â· base^^0^^ + c~~1~~ Â· base^^1^^ + â€¦ + c~~n~~ Â· base^^n^^`
    - Es. `587~~10~~ = 7Â·10^^0^^ + 8Â·10^^1^^ + 5Â·10^^2^^`
- Sistemi di numerazione posizionali di uso comune
    - Decimale (base 10; c: `0-9`)
    - Binario (base 2; c: `0-1`)
    - Esadecimale (base 16; c: `0-9, A-F`)

---

title: Codifica dellâ€™informazione

- Codifica: regole di corrispondenza per passare da un certo codice ad un altro
- Corrispondenza biunivoca
    - Tra una stringa di un codice
    - E una stringa di un altro codice
- Ad una certa stringa in un alfabeto ricco di simboli, corrisponde una stringa piÃ¹ lunga in un alfabeto piÃ¹ ridotto

---

title: Numeri binari
class: segue dark

---

title: Codice binario
figure: images/repr/sum-binary.jpg

- Base 2; c: `0-1`
- Informazione digitale nei calcolatori rappresentata con una sequenza di 0 e 1
    - Sistema ideato da Leibniz, ~1700
    - Calcolatore progr. Zuse, ~1940
- Ogni elemento di una sequenza binaria viene detto **bit**
- Una sequenza di *8 bit* viene detta **byte**

>

<https://www.wikihow.com/Convert-from-Binary-to-Decimal>

<https://www.wikihow.com/Convert-from-Decimal-to-Binary>

---

title: Codifica decimale â†’ binaria
class: large-table

- *(1)* Dividere il numero decimale per 2
- *(2)* Il resto Ã¨ il valore del nuovo bit, a sinistra
- *(3)* Il quoziente Ã¨ il numero con cui continuare *(loop)*
- Ossia continuare a dividere per 2 il quoziente, finchÃ© non si annulla
- Es.: `35~~10~~ = 00100011~~2~~`

n  | n // B | n % B | peso
---|-----|-----|-------
35 |  17 |   1 | 1 = 2^^0^^
17 |   8 |   1 | 2 = 2^^1^^
 8 |   4 |   0 | 4 = 2^^2^^
 4 |   2 |   0 | 8 = 2^^3^^
 2 |   1 |   0 | 16 = 2^^4^^
 1 |   0 |   1 | 32 = 2^^5^^

---

title: Numeri naturali
figure: images/repr/binary-fingers.svg
figcaption: ... 819

- Rappresentare un numero naturale `N` in forma binaria
- Occorrono `K` bit, t.c. `2^^K^^ > N`
- Es. 4 bit per numeri naturali da 0 a 15
- Un calcolatore assegna un numero fisso di bit per diversi tipi di informazione
    - Casi di valori non rappresentabili
    - **Overflow**, **underflow**

---

title: Esadecimale (Hex)
class: large-table

  Dec  | Bin       | Hex |   Dec  | Bin       | Hex |   Dec  | Bin       | Hex
-------|-----------|-----|--------|-----------|-----|--------|-----------|----
**00** | 0000 0000 |  00 | **16** | 0001 0000 |  10 | **32** | 0010 0000 |  20
**01** | 0000 0001 |  01 | **17** | 0001 0001 |  11 | **33** | 0010 0001 |  21
**02** | 0000 0010 |  02 | **18** | 0001 0010 |  12 | **34** | 0010 0010 |  22
**03** | 0000 0011 |  03 | **19** | 0001 0011 |  13 | **35** | 0010 0011 |  23
**04** | 0000 0100 |  04 | **20** | 0001 0100 |  14 | **36** | 0010 0100 |  24
**05** | 0000 0101 |  05 | **21** | 0001 0101 |  15 | **37** | 0010 0101 |  25
**06** | 0000 0110 |  06 | **22** | 0001 0110 |  16 | **38** | 0010 0110 |  26
**07** | 0000 0111 |  07 | **23** | 0001 0111 |  17 | **39** | 0010 0111 |  27
**08** | 0000 1000 |  08 | **24** | 0001 1000 |  18 | **40** | 0010 1000 |  28
**09** | 0000 1001 |  09 | **25** | 0001 1001 |  19 | **41** | 0010 1001 |  29
**10** | 0000 1010 |  0A | **26** | 0001 1010 |  1A | **42** | 0010 1010 |  2A
**11** | 0000 1011 |  0B | **27** | 0001 1011 |  1B | **43** | 0010 1011 |  2B
**12** | 0000 1100 |  0C | **28** | 0001 1100 |  1C | **44** | 0010 1100 |  2C
**13** | 0000 1101 |  0D | **29** | 0001 1101 |  1D | **45** | 0010 1101 |  2D
**14** | 0000 1110 |  0E | **30** | 0001 1110 |  1E | **46** | 0010 1110 |  2E
**15** | 0000 1111 |  0F | **31** | 0001 1111 |  1F | **47** | 0010 1111 |  2F

---

title: Bin â†” Hex
figure: images/repr/4bits.png

![](images/repr/bin-hex.png)

- Ogni gruppo di 4 bit: 16 configurazioni diverse
    - *Disposizioni con ripetizione*: `2^^4^^ = 16`
- Ciascuna configurazione corrisponde ad uno dei 16 simboli esadecimali

---

title: Somma e sottrazione

code: Binary

        1   1
    0 0 0 1 0 1 1 0 +
    0 0 0 1 0 1 0 1 =
    -----------------
    0 0 1 0 1 0 1 1

code: Binary

                0 10
    0 0 0 0 1 1 1 0 -
    0 0 0 0 0 1 0 1 =
    -----------------
    0 0 0 0 1 0 0 1

Attenzione a riporto e prestito (in alto)

---

title: Moltiplicazione

code: Binary

            1 0 1 1 x
            1 1 0 1 =
            ---------
            1 0 1 1 +
          0 0 0 0
        -------------
          0 1 0 1 1 +
        1 0 1 1
      ---------------
        1 1 0 1 1 1 +
      1 0 1 1
    -----------------
    1 0 0 0 1 1 1 1

---

title: Divisione

code: Binary

    1 0 1 1 0 1 : 1 1
    0 0          ---------
    -----         0 1 1 1 1
    1 0 1 -
      1 1
    -------
      1 0 1 -
        1 1
      -------
        1 0 0 -
          1 1
        -------
            1 1 -
            1 1
            -----
            0 0

---

title: Numeri interi
figure: images/repr/4bits-sign.png

- Occorre rappresentare anche i numeri negativi
    - Necessario riservare un bit per il segno
    - Ovvero, si dimezza il massimo modulo ammesso
- **Modulo e segno**
    - Il primo bit indica il segno
    - 0 positivo, 1 negativo

---

title: Complemento a due
figure: images/repr/4bits-sign.png

- Rappresentazione alternativa, *diversa da modulo e segno!*
- Numero negativo, ottenuto dal suo opposto positivo
    - Complemento il numero <br> (gli 1 diventano 0 e viceversa)
    - Sommo 1
- Anche cosÃ¬, il primo bit indica il segno
    - 0 positivo, 1 negativo
- *Attenzione*: bisogna conoscere codifica e num bit
    - Esempi seguenti: ogni intero con segno memorizzato in un singolo *byte*

---

title: Es. numero intero

- Avendo *un byte*, +35 Ã¨ in binario: **`0`**`0100011`
- Numero â€“35, in modulo e segno: **`1`**`0100011`
- Numero â€“35, in complemento a due: **`1`**`1011101`

code: Binary

    0 0 1 0 0 0 1 1 Â¬
    -----------------
    1 1 0 1 1 1 0 0 +
                  1 =
    -----------------
    1 1 0 1 1 1 0 1

`Â¬`: complemento semplice, bit a bit

---

title: Somma con segno

- Sommare 12 e -35 su 8 bit, modulo e segno
    - Sottrazione tra 35 e 12
    - Cambio di segno
- Stessa operazione, complemento a due
    - Semplice somma: `12 + -35 = -23`

code: Binary

    0 0 0 0 1 1 0 0 +
    1 1 0 1 1 1 0 1 =
    -----------------
    1 1 1 0 1 0 0 1

---

title: Numeri reali

- Insieme continuo, per grandezze analogiche
    - Rappresentabili solo in modo approssimato
- Parte frazionaria:
    - `F = c~~-1~~ Â· base^^-1^^ + â€¦ + c~~-n~~ Â· base^^-n^^`
- Due rappresentazioni *alternative*
    - **Virgola fissa**: segno, parte intera, parte decimale
    - **Virgola mobile**: segno, mantissa, esponente

---

title: Parte frazionaria in binario
class: large-table

- *(1)* Moltiplicare la parte frazionaria per 2
- *(2)* Assegnare la parte intera del risultato come valore del bit *(loop)*
- Ossia: continuare a moltiplicare per 2 la parte frazionaria del risultato... <br> finchÃ© non si annulla

fract | fract*B | int | peso
------|---------|-----|--------
0,375 | 0,750   | 0   | 2^^-1^^
0,750 | 1,500   | 1   | 2^^-2^^
0,500 | 1,000   | 1   | 2^^-3^^

---

title: Virgola fissa

- Numero espresso come: `r = (i, f)`
    - **`i`** Ã¨ la parte intera, `n~~1~~` bit
    - **`f`** Ã¨ la parte frazionaria, `n~~2~~` bit
- Precisione costante lungo lâ€™asse reale
    - P.es. `f` di 3 bit, valori consecutivi sempre distanziati di 1/8
    - Tra ciascun intero e il successivo, possiamo rappresentare 8 valori

![](images/repr/fixed-point.png)

---

title: Virgola mobile
class: large-image

- Numero espresso come: `r = Â±(1+f)Â·2^^e^^`
    - **`e`** Ã¨ l'esponente intero (o caratteristica), `n~~1~~` bit
    - **`f`** Ã¨ la parte frazionaria *(0 â‰¤ f < 1)*, `n~~2~~` bit
    - `2` Ã¨ la base, `1+f` Ã¨ anche detto *mantissa*
- Precisione variabile lungo lâ€™asse reale; p.es.:
    - `f âˆˆ {0, 1/4, 2/4, 3/4}`, 2 bit <br> `e âˆˆ {-2, -1, 0, 1}`, 2 bit

![](images/repr/float4.png)

>

<http://www.mathworks.com/company/newsletters/news_notes/pdf/Fall96Cleve.pdf>

---

title: IEEE 754 single & double

- Precisione singola: 32 bit
    - 1 x segno, 8 x esponente, 23 x frazione
- Precisione doppia: 64 bit
    - 1 x segno, 11 x esponente, 52 x frazione

![](images/repr/ieee754-32-ex.svg)
![](images/repr/ieee754-64.svg)

>

<https://www.wikihow.com/Convert-a-Number-from-Decimal-to-IEEE-754-Floating-Point-Representation>

---

title: IEEE 754 half-precision

- Rappresentazione usata nelle GPU, per velocizzare i calcoli
- `-118.625 = -1110110.101~~2~~ = -1.110110101~~2~~ Ã— 2^^6^^`
- Allâ€™esponente, su 5 bit, bisogna sommare `15` (`=2^^(5 âˆ’ 1)^^ âˆ’ 1`)

![](images/repr/ieee754-16-ex.svg)


---

title: Algebra di Boole
class: segue dark

---

title: Algebra di Boole

- Lâ€™algebra di Boole Ã¨ un formalismo che opera su variabili (dette *variabili booleane*)
- Le variabili booleane possono assumere due soli valori: `vero`, `falso`
- Sulle variabili booleane Ã¨ possibile definire delle funzioni (dette *funzioni booleane*)
- Anche le funzioni booleane possono assumere solo i due valori `vero` e `falso`

---

title: Funzione e tabella di veritÃ 
class: large-table

- Una *tabella di veritÃ * permette di definire una *funzione booleana*
- Valore risultante per ciascuna configurazione dei valori in ingresso
- A volte, *specifica incompleta* (certe configurazioni di ingressi non possono verificarsi) â†’ Non Ã¨ specificato alcun valore

 A | B | C | F~~1~~
---|---|---|---
 0 | 0 | 0 | 1
 0 | 0 | 1 | 0
 0 | 1 | 0 | 0
 0 | 1 | 1 | 1
 1 | 0 | 0 | 0
 1 | 0 | 1 | 1
 1 | 1 | 0 | 1
 1 | 1 | 1 | 1

---

title: Operatori di base
class: large-table

- Algebra di Boole: basata su un insieme di operatori
- Semplici funzioni, specificate con tabelle di veritÃ 

A | B | AÂ·B | A+B | AâŠ•B | Aâ†‘B | Aâ†“B
--|---|-----|-----|-----|-----|----
0 | 0 | 0   | 0   | 0   | 1   | 1
0 | 1 | 0   | 1   | 1   | 1   | 0
1 | 0 | 0   | 1   | 1   | 1   | 0
1 | 1 | 1   | 1   | 0   | 0   | 0

A | Â¬A
--|---
0 | 1
1 | 0

---

title: Espressione booleana
figure: images/repr/hair-logic.svg

- Operatori possono essere combinati in espressioni
- Altra forma di definizione di funzioni booleane
- Es. `F~~2~~(A, B, C) = AÂ·B + C`

Operatore | Simbolo
----------|--------
And       | Â· (âˆ§)
Or        | + (âˆ¨)
Not       | Â¬
Xor       | âŠ•
Nand      | â†‘
Nor       | â†“

---

title: ProprietÃ  degli operatori
class: large-table

ProprietÃ     | Not
-------------|--------
Complemento  | Â¬Â¬A = A

ProprietÃ     | And                       | Or
-------------|---------------------------|--------------------------
Commutativa  | A Â· B = B Â· A             | A + B = B + A
Associativa  | (AÂ·B) Â· C = A Â· (BÂ·C)     | (A+B) + C = A + (B+C)
Distributiva | A + (BÂ·C) = (A+B) Â· (A+C) | A Â· (B+C) = (AÂ·B) + (AÂ·C)
Idempotenza  | A Â· A = A                 | A + A = A
IdentitÃ      | A Â· 1 = A                 | A + 0 = A
Del limite   | A Â· 0 = 0                 | A + 1 = 1
Assorbimento | A Â· (A + B) = A           | A + (A Â· B) = A
Inverso      | A Â· Â¬ A = 0               | A + Â¬A = 1
De Morgan    | Â¬(AÂ·BÂ·Câ€¦) = Â¬A + Â¬B + Â¬Câ€¦ | Â¬(A+B+Câ€¦) = Â¬A Â· Â¬B Â· Â¬Câ€¦

>

Attenzione a De Morgan: errore comune!

---

title: De Morgan

code: py

    if x1 == x2 and y1 == y2:
        print("the points are equal")

code: py

    if x1 != x2 or y1 != y2:  # not (x1 == x2 and y1 == y2)
        print("the points are different")

- Python permette di confrontare tuple

code: py

    pt1 = x1, y1
    pt2 = x2, y2
    if pt1 != pt2:
        print("the points are different")

---

title: Forme canoniche
class: large-table

- **Somma di Prodotti (SP)**: si considerano le righe a 1
    - `F~~1~~(A, B, C) = (Â¬AÂ·Â¬BÂ·Â¬C) + (Â¬AÂ·BÂ·C) + (AÂ·Â¬BÂ·C) + (AÂ·BÂ·Â¬C) + (AÂ·BÂ·C)`
- **Prodotto di Somme (PS)**: si considerano le righe a 0, *negate*
    - `F~~1~~(A, B, C) = (A + B + Â¬C) Â· (A + Â¬B + C) Â· (Â¬A + B + C)`

 A | B | C | F~~1~~ | â†’ Forma canonica...
---|---|---|---|-----
 0 | 0 | 0 | 1 | â†’ SP
 0 | 0 | 1 | 0 | â†’ PS
 0 | 1 | 0 | 0 | â†’ PS
 0 | 1 | 1 | 1 | â†’ SP
 1 | 0 | 0 | 0 | â†’ PS
 1 | 0 | 1 | 1 | â†’ SP
 1 | 1 | 0 | 1 | â†’ SP
 1 | 1 | 1 | 1 | â†’ SP

---

title: Cenni di logica
class: segue dark

---

title: Proposizione

- Frase dichiarativa di senso compiuto che possa esser riconosciuta come â€œveraâ€ o â€œfalsaâ€
    - **Principio di non contraddizione**: un enunciato non puÃ² essere contemporaneamente vero e falso
    - **Principio del terzo escluso**: un enunciato Ã¨ vero o falso, non esiste una terza possibilitÃ  (*tertium non datur*)
- Ad esempio, sono proposizioni:
    - â€œIl cane Ã¨ un animaleâ€ - â€œ2 = 1â€ - â€œI triangoli hanno tre latiâ€
- ... Mentre non lo sono:
    - â€œIl caneâ€ - â€œChe ore sono?â€ - â€œSe 2 = 1â€ - â€œNon fumare!â€ - â€œIo sono bugiardoâ€ (*)

>

(*) Paradosso: non si puÃ² stabilire se la frase Ã¨ vera o falsa

Tarsia @ UniPI: <http://people.dm.unipi.it/tarsia/dida1011/logins05.pdf>

---

title: Connettivi logici

- Gli operatori booleani si usano anche con le proposizioni
    - â€œeâ€ (*congiunzione*, âˆ§)
    - â€œoâ€ (*disgiunzione*, âˆ¨)
    - â€œnonâ€ (*negazione*, Â¬)
    - Valgono le proprietÃ  giÃ  viste
- In logica, chiamati *connettivi*
    - Servono a legare proposizioni in forma piÃ¹ complessa

---

title: Connettivo condizionale o implicazione logica

- Esprime il legame â€œseâ€ ... â€œalloraâ€
    - P: â€œio pensoâ€ (*premessa*)
    - Q: â€œio esistoâ€ (*conseguenza*)
    - P â‡’ Q: â€œse penso allora esistoâ€
- P â‡’ Q si puÃ² leggere nei seguenti modi:
    - Se P allora Q
    - Da P segue Q
    - P Ã¨ *condizione sufficiente* per Q (se P Ã¨ vera, allora Q Ã¨ vera)
    - Q Ã¨ *condizione necessaria* per P (se Q Ã¨ falsa, allora P Ã¨ falsa)

---

title: VeritÃ  dell'implicazione

- P â‡’ Q Ã¨ falsa solo in un caso: quando P Ã¨ vera e Q Ã¨ falsa
    - Â¬(P â‡’ Q) = (P âˆ§ Â¬Q)
- Ne consegue che P â‡’ Q Ã¨ vera se P Ã¨ falsa o Q Ã¨ vera
    - P â‡’ Q = Â¬(P âˆ§ Â¬Q) = *[De Morgan]* <br> Â¬P âˆ¨ Â¬(Â¬Q) = *[Doppia negazione]* <br> Â¬P âˆ¨ Q
- Esempi di implicazioni vere:
    - â€œSe 5 Ã¨ un numero allora Roma Ã¨ una cittÃ â€
    - â€œSe Parigi Ã¨ la capitale d'Italia, allora 5 + 5 = 10â€
- L'mplicazione **non** soddisfa la proprietÃ  commutativa:
    - (P â‡’ Q) â‰  (Q â‡’ P)

---

title: Doppia implicazione

- P â‡” Q: valgono contemporaneamente le implicazioni P â‡’ Q e Q â‡’ P
- P â‡” Q Ã¨ vera quando P e Q sono entrambe vere o entrambe false
    - Applichiamo proprietÃ  distributiva e proprietÃ  dell'inverso
    - (P â‡’ Q) âˆ§ (Q â‡’ P) = <br> (Â¬P âˆ¨ Q) âˆ§ (Â¬Q âˆ¨ P) = <br> ((Â¬P) âˆ§ (Â¬Q âˆ¨ P)) âˆ¨ (Q âˆ§ ((Â¬Q) âˆ§ P)) = <br> ((Â¬P) âˆ§ Â¬Q) âˆ¨ (Â¬P âˆ§ P) âˆ¨ ((P âˆ§ Q) âˆ¨ (Â¬Q âˆ§ Q)) = <br> (P âˆ§ Q) âˆ¨ (Â¬P âˆ§ Â¬Q)

---

title: Deduzione logica

- Un *teorema* si riconduce allâ€™implicazione P â‡’ Q
    - P (*ipotesi*): proposizione che si assume vera
    - Q (*tesi*): proposizione di cui si vuole dedurre la veritÃ 
- Processo di *deduzione logica*, o *dimostrazione*, deve seguire ben precise regole di *inferenza*
    - Dimostrazione diretta (*modus ponens*)
    - Dimostrazione per assurdo (*modus tollens*)

---

title: Dimostrazione diretta, modus ponens

- Schema di ragionamento

 Premessa | Conseguenza
 ---|---
 (P â‡’ Q) vera <br> P vera | Q vera

- Esempio
    - Se c'Ã¨ sole, Ugo arriva in bici (implicazione)
    - C'Ã¨ sole (fatto)
    - Ugo arriva in bici (deduzione)
- Alla base dei sillogismi aristotelici (con quantificatori)
    - *Premessa maggiore*: â€œTutti gli uomini sono mortaliâ€
    - *Premessa minore*: â€œSocrate Ã¨ un uomoâ€
    - *Conclusione*: â€œSocrate Ã¨ mortaleâ€

---

title: Osservazioni sul modus ponens

- Il solo fatto di sapere che P â‡’ Q Ã¨ vera non consente di concludere niente su P e Q
- Sono possibili dimostrazioni con piÃ¹ passaggi intermedi
    - Se sono vere le implicazioni P â‡’ R, R â‡’ Q e se P Ã¨ vera, allora Ã¨ vera anche Q
    - ((P â‡’ R) âˆ§ (R â‡’ Q) âˆ§ P) â‡’ Q
- Schema di ragionamento

 Premessa | Conseguenza
 ---|---
 (P â‡’ R) vera <br> (R â‡’ Q) vera <br> P vera | Q vera

---

title: Dimostrazione per assurdo, modus tollens

- Se Ã¨ vera lâ€™implicazione Â¬Q â‡’ Â¬P ed Ã¨ vera P, allora Ã¨ vera anche Q
- Schema di ragionamento

 Premessa | Conseguenza
 ---|---
 (Â¬Q â‡’ Â¬P) vera <br> P vera | Q vera

- Esempio di teorema
    - P: mÂ·n â‰  0
    - Q: (m â‰  0) âˆ§ (n â‰  0)
    - Dimostrazione per assurdo: Â¬Q â‡’ Â¬P
    - Se (m = 0) oppure (n = 0), allora mÂ·n = 0

---

title: Predicato, o enunciato aperto

- Frase che contiene *variabili*
    - La veritÃ  della frase dipende dal valore delle variabili
    - Se variabili sostituite da valori, diventa proposizione
- Esempio
    - P(x): â€œx Ã¨ un numero dispariâ€
- Occorre definire il *dominio* delle variabili
- *Insieme di veritÃ * del predicato
    - Valori delle variabili che rendono vero l'enunciato
    - Sottoinsieme del dominio delle variabili

---

title: Predicati con connettivi

- P(x) âˆ§ Q(x) -- Vero per gli x che rendono veri entrambi i pred.
- P(x) âˆ¨ Q(x) -- Vero per gli x che rendono vero almeno un pred.
- Â¬P(x) -- Vero per gli x che rendono falso il pred.
- P(x) â‡’ Q(x) -- Vero per gli x che rendono falso P oppure vero Q
- P(x) â‡” Q(x) -- Vero per gli x che rendono i pred. entrambi falsi o entrambi veri

---

title: Quantificatori

- Un predicato puÃ² essere trasformato in una proposizione in due modi
    - Sostituendo la variabili con valori
    - *Quantificando* le sue variabili
    - Una variabile legata ad un quantificatore si dice *vincolata*, altrimenti *libera*
- I quantificatori logici sono due
    - Quantificatore **universale**
    - Quantificatore **esistenziale**

---

title: Quantificatore universale

- Una data proprietÃ  vale per tutti i valori possibili delle variabili
- `âˆ€x, P(x)` -- â€œPer ogni x, P(x) Ã¨ veroâ€
- Esempi
    - âˆ€n âˆˆ N, n Ã¨ multiplo di 4 â‡’ n Ã¨ pari
    - âˆ€x âˆˆ R âˆ€y âˆˆ R, (x + y)^^2^^ = x^^2^^ + 2xy + y^^2^^

---

title: Quantificatore esistenziale

- Una data proprietÃ  vale per almeno un valore delle variabili
- `âˆƒx : P(x)` -- â€œEsiste almeno un x tale che P(x) Ã¨ veroâ€
- Esempi
    - âˆƒn âˆˆ N: n Ã¨ pari -- Esiste almeno un numero pari
    - âˆƒx âˆˆ R: 2x + 1 = 0 -- L'equazione ammette almeno una soluzione
- Enunciati con âˆ„ riformulati con âˆ€ e negando il predicato
    - âˆ„x : x^^2^^ < 0
    - âˆ€x, x^^2^^ â‰¥ 0

---

title: ProprietÃ  dei quantificatori

- I quantificatori sono sostanzialmente *congiunzioni* o *disgiunzioni* allargate a tutti gli elementi di un insieme
- Due quantificatori dello stesso tipo *possono* essere scambiati di posto senza alterare la veritÃ  dellâ€™enunciato
- Invece, due quantificatori di diverso tipo *non possono* essere scambiati di posto
- I seguenti enunciati sono ben diversi
    - âˆ€x, âˆƒy : y â‰¥ x
    - âˆƒy : âˆ€x, y â‰¥ x

---

title: Negazione con quantificatori

- Per negare un enunciato che contiene quantificatori, occorrono due modifiche:
    - (1) Scambiare tra loro quantificatore universale âˆ€ e quantificatore esistenziale âˆƒ
    - (2) Negare il predicato
- Esempi
    - Â¬(âˆ€x, P(x)) â‡” âˆƒx : Â¬P(x)
    - Â¬(âˆƒx : P(x)) â‡” âˆ€x, Â¬P(x)

---

title: Operazioni tra insiemi
class: large-table

- Siano definiti due insiemi: A = {x : P(x)}, B = {x : Q(x)}

ProprietÃ  | Op. tra insiemi | Op. tra predicati
---|---|---
Commutativa | A âˆª B = B âˆª A | P âˆ¨ Q â‡” Q âˆ¨ P
Commutativa | A âˆ© B = B âˆ© A | P âˆ§ Q â‡” Q âˆ§ P
Associativa | (A âˆª B) âˆª C = A âˆª (B âˆª C) | (P âˆ¨ Q) âˆ¨ R â‡” P âˆ¨ (Q âˆ¨ R)
Associativa | (A âˆ© B) âˆ© C = A âˆ© (B âˆ© C) | (P âˆ§ Q) âˆ§ R â‡” P âˆ§ (Q âˆ§ R)
Distributiva | (A âˆª B) âˆ© C = (A âˆ© C) âˆª (B âˆ© C) | (P âˆ¨ Q) âˆ§ R â‡” (P âˆ§ R) âˆ¨ (Q âˆ§ R)
Distributiva | (A âˆ© B) âˆª C = (A âˆª C) âˆ© (B âˆª C) | (P âˆ§ Q) âˆ¨ R â‡” (P âˆ¨ R) âˆ§ (Q âˆ¨ R)
Doppia negazione | (B^^C^^)^^C^^ = B | Â¬(Â¬P) â‡” P
De Morgan | (A âˆª B)^^C^^ = A^^C^^ âˆ© B^^C^^ | Â¬(P âˆ¨ Q) â‡” Â¬P âˆ§ Â¬Q
De Morgan | (A âˆ© B)^^C^^ = A^^C^^ âˆª B^^C^^ | Â¬(P âˆ§ Q) â‡” Â¬P âˆ¨ Â¬Q

---

title: Principio di induzione

- Sia P(n) un predicato definito âˆ€n â‰¥ k, (n âˆˆ N, k âˆˆ N) tale che:
    - (1) P(k) Ã¨ vera
    - (2) âˆ€n â‰¥ k : supponendo P(n) vera segue che anche P(n+1) Ã¨ vera
    - Allora P(n) risulta vera per ogni n â‰¥ k
- In una formula:
    - (P(k) âˆ§ (âˆ€n â‰¥ k, P(n) â‡’ P(n + 1))) â‡’ (âˆ€n â‰¥ k, P(n))
- Esercizio: dimostrare la formula di Gauss
    - 1 + 2 + 3 + Â·Â·Â· + n = n (n + 1) / 2

---

title: ğŸ¤” Operazioni bit a bit in Python
class: break

- Operatori *bitwise*, applicati bit a bit
- Da non confondere con operatori logici (`and`, `or`, `not`)

code: py

    x = 0b1011  # bin value (11 dec)
    y = 0x2A    # hex value (42 dec)

    bin(42)     # '0b101010', a string
    hex(42)     # '0x2a', a string

    x & y       # bitwise AND (applied for each couple of bits)
    x | y       # bitwise OR
    x ^ y       # bitwise XOR
    ~x          # bitwise complement, 0b...11110100

    shift = 3  # some int
    x << shift  # x = x * (2 ** shift)
    y >> shift  # y = y / (2 ** shift)

