title: Linguaggio C++11
subtitle: Introduzione alla programmazione
figure: images/dev/cpp.png

---

title: Hello, C++

- File sorgente: `hello.cpp`
- `cout`: output su console, op. di inserimento `<<`
    - Possibile concatenare piÃ¹ operazioni di scrittura

code: c++

    #include <iostream>
    using namespace std;

    int main() {
        cout << "Hello, C++!" << endl;
    }

code: term

    g++ hello.cpp -o hello.exe

>

Compilatore: <https://tomamic.github.io/intro.html#11>

---

title: Leggere e scrivere

- `cin`: input da console, op. di estrazione `>>`
    - Possibile concatenare piÃ¹ operazioni di lettura
    - `getline(cin, line)`: lettura intera riga

code: c++

    #include <iostream>
    using namespace std;

    int main() {
        string name;
        int age;
        cout << "Name and age?" << endl;
        cin >> name >> age;
        cout << "Hello, " << name << "." << endl;
        cout << "You're " << age << " years old." << endl;
    }

---

title: Tipizzazione statica
figure: images/algo/my-shoes.png

- Una delle differenze principali: le comuni variabili non sono *riferimenti*, ma *contenitori* di dati
    - Occorrono **dichiarazioni** di tipo
    - Ma possibile *type inference* (`auto`)
- Tipi principali: `int`, `float` e `double`, `bool`, `string` e `char`

code: c++

    int x = 10;
    double h = 3.7;
    string s = "hello";

    auto y = 5;        // type inference
    auto k = 2.2;
    auto t = "hola"s;  // compiler settings: -std=c++14

---

title: Operazioni di base

- Operazioni su numeri: `+, -, *, /, %`
    - Anche incremento e decremento unitario: `++, --`
    - *Attenzione*: la divisione tra interi dÃ  risultato intero (`trunc`); il resto puÃ² essere negativo
    - Assegnamento: `=, +=, -=` ...
    - Confronti: `>, >=, <, <=, !=, ==`
    - *Attenzione*: i confronti **non** si possono concatenare
- Operazioni booleane (and, or, not): `&&, ||, !`

code: c++

    cout << (3 < 5) << endl;           // 1
    cout << (3 < 5 < 4) << endl;       // 1 (!)
    cout << (3 < 5 && 5 < 4) << endl;  // 0

---

title: Stringhe

- `string`: sequenza *mutevole* di byte (tipo `char`)
- Operazioni di confronto; concatenazione: `+`
- *Attenzione*: apici doppi per valori `string`, singoli per `char`

code: c++

    string sentence = "Lorem ipsum";
    sentence[6] = 'I';
    cout << sentence[6];  // 'I'

    int n = 5;
    string txt = to_string(n);
    int val = stoi(txt);  // see also `stod`, `stof`...

---

title: Decisioni
figure: images/algo/words.svg

code: c++

    string a, b;
    cin >> a >> b;
    if (a < b) {
        cout << "The words are ordered" << endl;
    } else if (a > b) {
        cout << "The words are inverted" << endl;
    } else {
        cout << "The words are equal" << endl;
    }

>

<http://tomamic.github.io/p1-algoritmi.html#16>

---

title: Iterazioni
figure: images/algo/average.svg

code: c++

    int val, total = 0, count = 0;
    cout << "Val (0 to finish)? ";
    cin >> val;
    while (val != 0) {
        total += val;
        ++count;
        cout << "Val (0 to finish)? ";
        cin >> val;
    }
    if (count > 0) {
        cout << "Avg: " << total / float(count) << endl;
    }

>

<http://tomamic.github.io/p1-algoritmi.html#20>

---

title: Funzioni

code: c++

    #include <cmath>
    #include <iostream>
    using namespace std;

    double hypotenuse(double a, double b) {
        auto c = sqrt(a * a + b * b);
        return c;
    }

    int main() {
        auto side1 = 3.0, side2 = 4.0;
        auto side3 = hypotenuse(side1, side2);
        cout << "3rd side: " << side3 << endl;
    }

>

<http://tomamic.github.io/p2-oggetti.html#4>

---

title: Parametri per riferimento ðŸ¤”

- Parametri passati per riferimento sono *alias*
    - Le modifiche riguardano anche le variabili esterne
    - Limitarne l'uso!

code: c++

    // pass by reference: external vars can be modified
    void swap(int& m, int& n) {
        int tmp = m;
        m = n; n = tmp;
    }

    int main() {
        int a = 5, b = 7;
        swap(a, b);
        cout << a << " " << b << endl;
    }

---

title: Strutture in g2d

- Composizione di tipi elementari in strutture composte
    - Possibile alternativa alle tuple di Python
- Le seguenti `struct` sono definite in `g2d/actor.hpp`

code: c++

    struct Point { int x, y; };
    struct Size { int w, h; };
    struct Rect { int x, y, w, h; };
    struct Color { int r, g, b; };

---

title: Grafica con g2d

code: c++

    #include "g2d/canvas.hpp"  // use your path!
    auto x = 50, y = 50, dx = 5, dy = 0;
    auto image = g2d::load_image("ball.png");

    void tick() {
        if (g2d::key_pressed("LeftButton")) { dx = -dx; }
        g2d::clear_canvas();
        g2d::draw_image(image, {x, y});
        x += dx;
    }
    int main() {
        g2d::init_canvas({480, 360});
        g2d::main_loop(tick);
    }

code: term

    g++ *.cpp -pthread

---

title: Numeri casuali

code: C++

    #include <iostream>
    #include <cstdlib>
    #include <ctime>
    using namespace std;

    int main() {
        srand(time(nullptr));           // just once! (initial seed
                                        // for random numbers)
        for (int i = 0; i < 10; ++i) {
            int r = 1 + rand() % 90;    // random value: 1 <= r <= 90
            cout << r << endl;
        }
    }

>

In alternativa (con estremi inclusi): `g2d::randint(1, 90)`

---

title: Vector, array dinamici
figure: images/fun/shopping-list.jpg

code: c++

    #include <vector>

code: c++

    vector<string> grocery = {"spam", "egg", "beans"};  // init list
    cout << grocery[1] << endl;  // egg
    cout << grocery.size() << endl;  // 3
    grocery[0] = "sausage";  // replace an elem

    grocery.push_back("bacon");  // add elem to the end
    grocery.pop_back();  // remove last elem

>

<http://tomamic.github.io/p3-composizione.html#4>

---

title: Cicli for

code: c++

    for (auto product : grocery) {  // for each product in grocery
        cout << product << endl;
    }
    // it works also on a string!

code: c++

    for (int i = 0; i < 5; ++i) {  // for each i : 0 <= i < 5
        cout << i * i << endl;
    }

code: c++

    int i = 0;
    while (i < 5) {  // equivalent while
        cout << i * i << endl;
        ++i;
    }

>

<http://tomamic.github.io/p3-composizione.html#8>

---

title: Somma colonne: matrice

code: c++

    vector<vector<int>> matrix = { {2, 4, 3, 8},
                                   {9, 3, 2, 7},
                                   {5, 6, 9, 1} };
    auto rows = matrix.size();
    auto cols = matrix[0].size();
    for (auto x = 0; x < cols; ++x) {
        auto total = 0;
        for (auto y = 0; y < rows; ++y) {
            total += matrix[y][x];
        }
        cout << "Col #" << x << " sums to " << total << endl;
    }

>

<http://tomamic.github.io/p5-matrici.html#9>

---

title: Allocazione di vector

- Metodo `assign` per allocare una lista o una matrice
    - *Dimensione* nota
    - *Valore iniziale* uguale per tutti gli elementi

code: c++

    vector<string> some_list;
    some_list.assign(10, ""); // 10 strings

code: c++

    vector<vector<char>> some_matrix;
    some_matrix.assign(rows, vector<char>(cols, '-'));

---

title: Iteratori ed algoritmi
figure: images/fun/iterator.png
class: large-figure

code: c++

    #include <algorithm>
    // count, find, sort etc.

code: c++

    // insert at index 1, other elems shift
    grocery.insert(grocery.begin() + 1, "bacon");
    // remove elem at index 1, other elems shift back
    grocery.erase(grocery.begin() + 1);

code: c++

    auto pos = find(grocery.begin(), grocery.end(), "egg");
    if (pos != grocery.end()) {
        // true, grocery contains "egg"
        grocery.erase(pos);
    }

>

<http://tomamic.github.io/p3-composizione.html#4>

---

title: Puntatori
figure: images/oop/pointer.png

- Ogni dato presente in memoria ha un indirizzo: variabile puntatore per memorizzarlo
    - Operatore `&` per indirizzo di un dato
    - Op. `*` per accesso a dato puntato (*dereferenziazione*)

code: c++

    char i = 56;  // a byte
    char* p;      // a ptr to some byte (uninitialized)
    p = &i;       // now p points to i
    *p = *p + 1;  // ++i
    p = nullptr;  // ptr to nothing

---

title: Oggetti
class: segue dark

---

title: Definizione di una classe
figure: images/oop/ball-object.svg images/oop/ball-uml.svg
figcaption: Class diagram UML

code: c++

    class Ball {
        int x_, y_;             // private stuff
        int dx_ = 5, dy_ = 5;
    public:
        Ball(int x0, int y0) {  // contructor
            x_ = x0; y_ = y0;
        }
        void Ball::move() {
            if (x_+dx_ < 0 || x_+dx_ > 480) dx_ = -dx_;
            if (y_+dy_ < 0 || y_+dy_ > 360) dy_ = -dy_;
            x_ += dx_; y_ += dy_;
        }
        int Ball::get_x() { return x_; }
        int Ball::get_y() { return y_; }
    };

---

title: Creazione ed uso degli oggetti
figure: images/oop/balls.png

code: c++

    int main() {
        Ball b1{40, 80};
        Ball b2{80, 40};

        for (auto i = 0; i < 25; ++i) {
            b1.move();
            b2.move();
            cout << b1.get_x() << ", " << b1.get_y() << endl;
            cout << b2.get_x() << ", " << b2.get_y() << endl << endl;
        }
    }

---

title: Allocazione dinamica

code: c++

    Ball b1{40, 80};
    Ball* b2 = new Ball{80, 40};
    // Ball* alias1 = &b1; // no new ball is created
    // Ball* alias2 = b2;  // no new ball is created

    for (auto i = 0; i < 25; ++i) {
        b1.move();
        b2->move();
        cout << b1.get_x() << ", " << b1.get_y() << endl;
        cout << b2->get_x() << ", " << b2->get_y() << endl << endl;
    }
    delete b2;

- No *garbage collection*: a `new` deve corrispondere `delete`

---

title: Cppyy: Chiamare C++ da Python

code: term

    pip3 install cppyy

code: py

    import cppyy
    cppyy.include("ball.cpp")
    from cppyy.gbl import Ball

    b = Ball(150, 200)
    for i in range(10):
        b.move()
        print(b.get_x(), b.get_y())

---

title: Livelli di astrazione
class: segue dark

---

title: Fattoria parlante
figure: images/oop/animals.png

- *Classe base* come **interfaccia astratta**
- Es. `Animal`:
    - Tutti fanno un verso (*interfaccia*)
    - Ognuno lo fa diverso (*polimorfismo*)

code: c++

    class Animal {
    public:
        virtual void say() = 0;
    };

- Un metodo `virtual` *puÃ²* essere (ri)definito dalle sottoclassi
- Un metodo `=0` *deve* essere definito dalle sottoclassi
>

<https://github.com/tomamic/fondinfo/blob/master/cpp/animals/main.cpp>

---

title: Classi concrete
figure: images/oop/polymorphism.png

code: c++

    class Dog : public Animal {
        string name_;
    public:
        Dog(string name) { name_ = name; }
        void say() {
            cout << "I am " << name_ << " Dog. "
                 << "I say: WOOF!" << endl;
        }
    };
    class Cat : public Animal {
        /* ... */
        void say() {
            cout << "I am " << name_ << " Cat. "
                 << "I say: MEOW!" << endl;
        }
    };

---

title: Lista di puntatori ad oggetti
figure: images/oop/peppa.png

code: c++

    auto d = new Dog("Danny");
    auto c = new Cat("Candy");
    auto p1 = new Pig("Peppa");
    auto p2 = new Pig("George");
    // Polimorphism requires pointers to objects.
    // Elements can be added with push_back, too.
    vector<Animal*> animals = {d, c, p1, p2};
    for (auto a : animals) { a->say(); }

code: output

    I am Danny Dog. I say: WOOF!
    I am Candy Cat. I say: MEOW!
    I am Peppa Pig. I say: OINK!
    I am George Pig. I say: OINK!

---

title: Metodi virtuali puri
figure: images/oop/actor.svg

- Es.: metodo `move` di `Actor`
    - `virtual`: il metodo puÃ² essere ridefinito nelle sottoclassi (*polimorfo*)
    - `= 0`: il metodo non Ã¨ implementato qui (la classe Ã¨ *astratta*)
    - Polimorfismo C++ funziona solo con puntatori a oggetti

code: c++

    class Actor {
        virtual void move() = 0;
        // ...
    };

>

<https://github.com/tomamic/fondinfo/blob/master/cpp/bounce/actor.h>

---

title: Fifteen â€“ Gioco astratto
figure: images/qt/fifteen-puzzle.jpg

code: C++

    class BoardGame {
    public:
        virtual void play_at(int x, int y) = 0;
        virtual void flag_at(int x, int y) = 0;
        virtual int cols() = 0;
        virtual int rows() = 0;
        virtual string get_val(int x, int y) = 0;
        virtual bool finished() = 0;
        virtual string message() = 0;

        virtual ~BoardGame() {}
    };

>

<https://github.com/tomamic/fondinfo/blob/master/cpp/boardgames/boardgame.h>

---

title: Gioco a console

code: C++

    void print_game(BoardGame* game) {
        for (auto y = 0; y < game->rows(); ++y) {
            for (auto x = 0; x < game->cols(); ++x) {
                cout << setw(3) << game->get_val(x, y);
            }
            cout << endl;
        }
    }
    void play_game(BoardGame* game) {
        print_game(game);
        while (! game->finished()) {
            int x, y; cin >> x >> y;
            game->play_at(x, y);
            print_game(game);
        }
        cout << game->message() << endl;
    }

---

title: Compilazione separata ðŸ¤”

- C++: definizione della classe separata dalla implementazione dei metodi
    - Definizione fornita agli utenti
    - Implementazione compilata in libreria
- Sorgenti organizzati in 3 file:
    - `ball.h` â€“ definizione della classe
    - `ball.cpp` â€“ implementazione dei metodi
    - `main.cpp` â€“ applicazione che usa la classe
    - Dall'ambiente di sviluppo: *Add new â†’ C++ Class*

---

title: Definizione: ball.h ðŸ¤”
figure: images/oop/ball-object.svg images/oop/ball-uml.svg
figcaption: Class diagram UML

code: c++

    class Ball {
    public:
        Ball(int x0, int y0);
        void move();
        int get_x();
        int get_y();

        static const int ARENA_W = 320, ARENA_H = 240;
        static const int W = 20, H = 20;

    private:
        int x_;
        int y_;
        int dx_ = 5;
        int dy_ = 5;
    };

---

title: Implementazione: ball.cpp ðŸ¤”
figure: images/oop/anim-bounce.png

code: c++

    #include "ball.h"

    Ball::Ball(int x0, int y0) {
        x_ = x0; y_ = y0;
    }
    void Ball::move() {
        if (x_ + dx_ < 0 || x_ + dx_ + W > ARENA_W) dx_ = -dx_;
        if (y_ + dy_ < 0 || y_ + dy_ + H > ARENA_H) dy_ = -dy_;
        x_ += dx_; y_ += dy_;
    }
    int Ball::get_x() {
        return x_;
    }
    int Ball::get_y() {
        return y_;
    }

---

title: Applicazione: main.cpp ðŸ¤”
figure: images/oop/balls.png

code: c++

    #include "ball.h"
    // ...
    int main() {
        Ball b1{40, 80};
        Ball b2{80, 40};

        for (auto i = 0; i < 25; ++i) {
            b1.move();
            b2.move();
            cout << b1.get_x() << ", " << b1.get_y() << endl;
            cout << b2.get_x() << ", " << b2.get_y() << endl << endl;
        }
    }

---

title: Swig: C++ per moduli Python ðŸ¤”

code: file: ball.i

    %module ball
    %include "std_string.i"
    %{
    #include "ball.h"  /* Include the header in the wrapper code */
    %}
    %include "ball.h"  /* Parse the header to generate wrappers */

code: term

    swig -python -c++ ball.i
    g++ -fPIC -shared *.cpp *.cxx -I/usr/include/python3.6m -o _$module.so

code: py

    from ball import Ball
    b = Ball(150, 200)
    for i in range(10):
        b.move()
        print(b.get_x(), b.get_y())

---

title: Output su file ðŸ¤”

code: c++

    #include <fstream>

code: c++

    int n; float r; string w;
    cin >> n >> r >> w;

    ofstream file2{"output.txt"};  // file output stream
    if (file2) {                   // is stream available?
        file2 << "Values: " << n << " " << r << " " << w << endl;
    }
    file2.close();

---

title: Lettura di righe ðŸ¤”

code: c++

    ifstream file1{"input.txt"};  // when finished, close file1!

code: c++

    string first_line, second_line;
    getline(file1, first_line);   // no newline at end
    getline(file1, second_line);  // no newline at end

code: c++

    string whole_text;
    getline(file1, whole_text, '\0');  // read whole file

code: c++

    // for each line in file1...
    for (string line; getline(file1, line);) {
        cout << line << endl;
    }

>

<http://tomamic.github.io/p5-matrici.html#4>

---

title: Flussi e stringhe ðŸ¤”

- Si puÃ² gestire una stringa come uno stream
    - `istringstream`, `ostringstream` in libreria `<sstream>`
    - Per estrarre valori ed inserire valori, rispettivamente

code: c++

    /* Split a text into a sequence of strings */
    string text = "one:two::three";
    istringstream sstr{text};  // a stream view on a string
    for (string item; getline(sstr, item, ':');) {
        cout << "- " << item << endl;
    }

code: output

    - one
    - two
    -
    - three

---

title: Lettura di dati ðŸ¤”

code: c++

    ifstream file1{"input.txt"};

code: c++

    if (file1) {                         // is stream available?
        int n; float r; string w;
        file1 >> n >> r >> w;
    }

code: c++

    for (int val; file1 >> val;) {       // or float, string ...
        cout << setw(4) << val << endl;  // val occupies 4 chars
    }                                    // setw in <iomanip>

code: c++

    file1 >> noskipws;                   // scan also whitespaces
    for (char val; file1 >> val;) {      // for each char in file1
        cout << val << endl;
    }

---

title: Do-while ðŸ¤”
class: break

code: c++

    int val, tot = 0, count = 0;
    do {
        cout << "Val (0 to end)? ";
        cin >> val;
        if (val != 0) {
            tot += val;
            ++count;
        }
    } while (val != 0);  // the check is at the end
    if (count > 0) {
        cout << "Avg: " << tot / float(count);
    }

---

title: Switch ðŸ¤”

code: c++

    int choice; cin >> choice;
    switch (choice) {
        case 1: cout << "First option"; break;
        case 2: cout << "Second option"; break;
        default: cout << "Error";
    }

---

title: Composizione
figure: images/oop/actors.svg
class: break

code: c++

    class Arena {  // ...
    public:
        void add(Actor* a);
        void move_all();
    private:
        vector<Actor*> actors;
    };

code: c++

    void Arena::add(Actor* c) {
        actors.push_back(a);
    }
    void Arena::move_all() {
        for (auto a : actors) a->move();
    }

---

title: EreditarietÃ  e polimorfismo

code: c++

    arena->add(new Ball(4, 8));
    arena->add(new Ghost(12,4));
    arena->move_all();

code: c++

    class Ghost: public Actor {
        // ...
        void move() {
            vector<int> vals = {-5, 0, 5};
            int dx = vals[rand() % 3];  // one of {-5, 0, +5}
            int dy = vals[rand() % 3];
            x = (x + dx + arena->width()) % arena->width();
            y = (y + dy + arena->height()) % arena->height();
        }
    };

---

title: Qt
class: segue dark break

---

title:  Rettangoli e cerchi con Qt
figure: images/qt/slogan.png images/oop/raster-coord.png

code: C++

    #include <QtWidgets>

code: C++

    QPixmap screen{600, 400}; QPainter painter{&screen};

    painter.setBrush(QColor{255, 255, 0});
    painter.drawRect(50, 75, 90, 50);

    painter.setBrush(QColor{0, 0, 255});
    painter.drawEllipse(QPoint{300, 50}, 20, 20);

    QLabel label; label.setPixmap(screen); label.show();

code: Project

    QT += widgets
    CONFIG += console c++11

>

Progetto: *Application* â†’ *Qt Widgets Application*

---

title: Ciclo di animazione in Qt

code: C++

    // fields: int x = 0; QPixmap image{"ball.png"};

    Widget::Widget() {
        startTimer(1000 / 60);  // 60 fps
    }
    void Widget::timerEvent(QTimerEvent* event) {
        x = (x + 5) % 600;  // or width()
        update();           // async: this widget should be redrawn
    }
    void Widget::paintEvent(QPaintEvent* event) {
        QPainter painter{this};
        painter.drawPixmap(x, 10, image);
    }

>

Progetto: *Application* â†’ *Qt Widgets Application*

---

title: Fifteen â€“ Gui generica
figure: images/qt/puzzle.png

code: C++

    class BoardGameGui : public QWidget {
        Q_OBJECT
    public:
        BoardGameGui(BoardGame* game);
        void handle_click(int x, int y);
        void update_button(int x, int y);
        void update_all_buttons();
    private:
        BoardGame* game_;
        int cols_, rows_;
    };

---

title: Strutture dati lineari
class: segue dark

---

title: Vector, array dinamici
figure: images/fun/dynamic-array.svg
class: large-figure

- **Array**: area di memoria che contiene in *celle contigue* elementi tutti dello *stesso tipo*
- Usato internamente dai `vector` del C++
    - Riallocazione dinamica e trasparente per inserimenti e rimozioni
- `Vector` come **array dinamici**
    - Accesso casuale: `O(1)`
    - Aggiunta o rimozione in fondo all'array: `O(1)`, ma a volte riallocazione
    - Inserimento o rimozione: `O(n)`

---

title: Vector di float

code: C++

    class FloatVector {  // ...
        int capacity_;
        int size_;
        float* data_;
    public:
        FloatVector(int size, float val);
        float get(int pos);
        void set(int pos, float val);
        void insert(int pos, float val);
        float remove(int pos);
        int size();
    };

Implementazione nel repository di esempi

---

title: Inserimento in vector

code: C++

    void FloatVector::insert(int pos, float val) {
        if (pos < 0 || pos > size_) throw out_of_range("wrong pos");
        if (size_ == capacity_) expand_capacity();
        for (int i = size_; i > pos; --i) data_[i] = data_[i - 1];
        data_[pos] = val;
        ++size_;
    }
    void FloatVector::expand_capacity() {
        capacity_ *= 2;
        float* bigger = new float[capacity_];
        for (int i = 0; i < size_; i++) bigger[i] = data_[i];
        delete[] data_;
        data_ = bigger;
    }

---

title: Liste concatenate

![](images/fun/linked-list.svg)

- Ciascun **nodo** contiene un *valore* della lista ed un *puntatore* al nodo successivo
    - Accesso casuale: `O(n)`
    - Aggiunta o rimozione in testa all'array: `O(1)`
    - Aggiunta o rimozione in fondo all'array: `O(n)`, oppure `O(1)` se noto ultimo nodo
    - Inserimento o rimozione: `O(1) + O(n)` per ricerca

---

title: Lista di float

code: C++

    struct Node {
        float val;
        Node* next;
    };
    class FloatList {  // ...
        Node* head_; int size_;
    public:
        FloatList(int size, float val);
        float get(int pos);
        void set(int pos, float val);
        void insert(int pos, float val);
        float remove(int pos);
        int size();
    };

Implementazione nel repository di esempi

---

title: Inserimento in lista

code: C++

    void FloatList::insert(int pos, float val) {
        if (pos < 0 || pos > size_) throw out_of_range("wrong pos");
        if (pos == 0) {
            head_ = new Node{val, head_};
        } else {
            Node* n = head_;
            for (int i = 0; i < pos - 1; ++i) n = n->next;
            n->next = new Node{val, n->next};
        }
        ++size_;
    }

---

title: Template C++

- **Programmazione generica**: codice che opera su *tipi parametrizzati*
    - Es. liste di `int`, `string` ecc.: cambia solo il tipo di dato!
- **Template**: meccanismo di programmazione generica in C++
    - Generaz. trasparente di codice specializzato per un tipo
    - Es. `vector<float>` genera una classe â‰ˆ `FloatVector`

code: C++

    template <class T>
    T max(T a, T b) {
        if (a >= b) return a;
        return b;
    }

code: C++

    double x = max<double>(5.0, 3.5);  # <double>, <int>: optional
    int i = max<int>(4, 6);            # inferred from parameters

