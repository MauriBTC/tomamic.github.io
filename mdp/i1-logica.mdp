title: Logica matematica
subtitle: Introduzione all'informatica
figure: images/repr/logical-problem.png

---

title: Algebra di Boole
class: segue dark

---

title: Algebra di Boole
figure: images/hist/george-boole.jpg
figcaption: George Boole, 1815-1864

- Lâ€™algebra di Boole Ã¨ un formalismo che opera su variabili (dette *variabili booleane*)
- Le variabili booleane possono assumere due soli valori
    - `Vero`: 1
    - `Falso`: 0
- Sulle variabili booleane Ã¨ possibile definire delle funzioni (dette *funzioni booleane*)
- Anche le funzioni booleane possono assumere solo i due valori `vero` e `falso`

---

title: Funzione e tabella di veritÃ 
class: large-table

- Una *tabella di veritÃ * permette di definire una *funzione booleana*
- Valore risultante per ciascuna configurazione dei valori in ingresso

 A | B | C | F~~1~~
---|---|---|---
 0 | 0 | 0 | 1
 0 | 0 | 1 | 0
 0 | 1 | 0 | 0
 0 | 1 | 1 | 1
 1 | 0 | 0 | 0
 1 | 0 | 1 | 1
 1 | 1 | 0 | 1
 1 | 1 | 1 | 1

>

A volte, *specifica incompleta*: certe configurazioni di ingressi non possono verificarsi, perciÃ² non Ã¨ specificato alcun valore

---

title: Operatori di base
class: large-table

- Algebra di Boole: basata su un insieme di operatori
- Semplici funzioni, specificate con tabelle di veritÃ 

A | B | AÂ·B | A+B | AâŠ•B | AâŠ¼B | AâŠ½B
--|---|-----|-----|-----|-----|----
0 | 0 | 0   | 0   | 0   | 1   | 1
0 | 1 | 0   | 1   | 1   | 1   | 0
1 | 0 | 0   | 1   | 1   | 1   | 0
1 | 1 | 1   | 1   | 0   | 0   | 0

A | Â¬A
--|---
0 | 1
1 | 0

---

title: Espressione booleana
figure: images/repr/hair-logic.svg

- Operatori possono essere combinati in espressioni
- Altra forma di definizione di funzioni booleane
- Es. `F~~2~~(A, B, C) = AÂ·B + C`

Operatore | Simbolo
----------|--------
And       | `âˆ§` (oppure `Â·`)
Or        | `âˆ¨` (oppure `+`)
Not       | `Â¬` (o sovralinea)
Xor       | `âŠ•`
Nand      | `âŠ¼`
Nor       | `âŠ½`

---

title: ProprietÃ  degli operatori
class: large-table

- Dimostrazione: si confrontano le due tabelle di veritÃ 

ProprietÃ     | Not
-------------|--------
Complemento  | Â¬Â¬A = A

ProprietÃ     | And                         | Or
-------------|-----------------------------|--------------------------
Commutativa  | `A Â· B = B Â· A`             | `A + B = B + A`
Associativa  | `(AÂ·B) Â· C = A Â· (BÂ·C)`     | `(A+B) + C = A + (B+C)`
Distributiva | `A + (BÂ·C) = (A+B) Â· (A+C)` | `A Â· (B+C) = (AÂ·B) + (AÂ·C)`
Idempotenza  | `A Â· A = A`                 | `A + A = A`
IdentitÃ      | `A Â· 1 = A`                 | `A + 0 = A`
Del limite   | `A Â· 0 = 0`                 | `A + 1 = 1`
Assorbimento | `A Â· (A+B) = A`             | `A + (AÂ·B) = A`
Inverso      | `A Â· Â¬A = 0`                | `A + Â¬A = 1`
De Morgan    | `Â¬(AÂ·BÂ·Câ€¦) = Â¬A + Â¬B + Â¬Câ€¦` | `Â¬(A+B+Câ€¦) = Â¬A Â· Â¬B Â· Â¬Câ€¦`

>

Attenzione a De Morgan: errore comune!

---

title: De Morgan

code: py

    if x1 == x2 and y1 == y2:
        print("the points are equal")

code: py

    if x1 != x2 or y1 != y2:  # not (x1 == x2 and y1 == y2)
        print("the points are different")

- Python permette di confrontare tuple

code: py

    pt1 = x1, y1
    pt2 = x2, y2
    if pt1 != pt2:
        print("the points are different")

---

title: Forme canoniche
class: large-table

- **Somma di Prodotti (SP)**: si considerano le righe a 1
    - `F~~1~~(A, B, C) = (Â¬AÂ·Â¬BÂ·Â¬C) + (Â¬AÂ·BÂ·C) + (AÂ·Â¬BÂ·C) + (AÂ·BÂ·Â¬C) + (AÂ·BÂ·C)`
- **Prodotto di Somme (PS)**: si considerano le righe a 0, *negate*
    - `F~~1~~(A, B, C) = (A + B + Â¬C) Â· (A + Â¬B + C) Â· (Â¬A + B + C)`

 A | B | C | F~~1~~ | â†’ Forma canonica...
---|---|---|---|-----
 0 | 0 | 0 | 1 | â†’ SP
 0 | 0 | 1 | 0 | â†’ PS
 0 | 1 | 0 | 0 | â†’ PS
 0 | 1 | 1 | 1 | â†’ SP
 1 | 0 | 0 | 0 | â†’ PS
 1 | 0 | 1 | 1 | â†’ SP
 1 | 1 | 0 | 1 | â†’ SP
 1 | 1 | 1 | 1 | â†’ SP

---

title: Logica delle proposizioni
class: segue dark

---

title: Proposizione

- Frase dichiarativa (*enunciato*) di senso compiuto che possa esser riconosciuta come â€œveraâ€ o â€œfalsaâ€
    - **Principio di non contraddizione**: un enunciato non puÃ² essere contemporaneamente vero e falso
    - **Principio del terzo escluso**: un enunciato Ã¨ vero o falso, non esiste una terza possibilitÃ  (*tertium non datur*)
- Ad esempio, sono proposizioni:
    - â€œIl cane Ã¨ un animaleâ€ - â€œ2 = 1â€ - â€œI triangoli hanno tre latiâ€
- ... Mentre non lo sono:
    - â€œIl caneâ€ - â€œChe ora Ã¨?â€ - â€œSe 2 = 1â€ - â€œNon fumare!â€ - â€œIo sono bugiardoâ€ (*)

>

(*) Paradosso: non si puÃ² stabilire se la frase Ã¨ vera o falsa

Tarsia @ UniPI: <http://people.dm.unipi.it/tarsia/dida1011/logins05.pdf>

---

title: Connettivi logici

- Gli operatori booleani si usano anche con le proposizioni
    - â€œeâ€ (*congiunzione*, `âˆ§`)
    - â€œoâ€ (*disgiunzione*, `âˆ¨`)
    - â€œnonâ€ (*negazione*, `Â¬`)
    - Valgono le proprietÃ  giÃ  viste
- In logica, chiamati *connettivi*
    - Servono a legare proposizioni in forma piÃ¹ complessa

---

title: Implicazione logica

- **Connettivo condizionale**: esprime il legame â€œseâ€ ... â€œalloraâ€
    - `P`: â€œio pensoâ€ (*premessa*)
    - `Q`: â€œio esistoâ€ (*conseguenza*)
    - `P â‡’ Q`: â€œse penso allora esistoâ€
- `P â‡’ Q` si puÃ² leggere anche nei seguenti modi:
    - Da `P` segue `Q`
    - `P` Ã¨ *condizione sufficiente* per `Q` (se `P` vera, allora `Q` vera)
    - `Q` Ã¨ *condizione necessaria* per `P` (se `Q` falsa, allora `P` falsa)
- Esempi di implicazioni vere:
    - â€œSe 5 Ã¨ un numero allora Roma Ã¨ una cittÃ â€
    - â€œSe Parigi Ã¨ la capitale d'Italia, allora 5 + 5 = 10â€

---

title: VeritÃ  dell'implicazione

`P` | `Q` | `P â‡’ Q`
----|-----|--------
 F  |  F  |  T
 F  |  T  |  T
 T  |  F  |  F
 T  |  T  |  T

- `P â‡’ Q` Ã¨ falsa solo in un caso: `P` vera e `Q` falsa
    - `Â¬(P â‡’ Q) = (P âˆ§ Â¬Q)`
    - `P â‡’ Q = Â¬(P âˆ§ Â¬Q) =` *[De Morgan]* <br> `Â¬P âˆ¨ Â¬(Â¬Q) =` *[Doppia negazione]* <br> `Â¬P âˆ¨ Q` (implicazione vera quando: `P` falsa, o `Q` vera)
- L'implicazione **non** soddisfa la proprietÃ  commutativa:
    - `(P â‡’ Q) â‰  (Q â‡’ P)`

---

title: Doppia implicazione

`P` | `Q` | `P â‡’ Q` | `Q â‡’ P` | `P â‡” Q`
----|-----|---------|---------|--------
 F  |  F  |  T      |  T      |  T
 F  |  T  |  T      |  F      |  F
 T  |  F  |  F      |  T      |  F
 T  |  T  |  T      |  T      |  T

- `P â‡” Q`: valgono entrambe le implicazioni, `(Pâ‡’Q) âˆ§ (Qâ‡’P)`
- `P â‡” Q` vera quando: `P` e `Q` entrambe vere, o entrambe false
    - Da proprietÃ  distributiva e proprietÃ  dell'inverso
    - `(Pâ‡’Q) âˆ§ (Qâ‡’P) =` <br> `(Â¬Pâˆ¨Q) âˆ§ (Â¬Qâˆ¨P) =` <br> `(Â¬P âˆ§ (Â¬Qâˆ¨P)) âˆ¨ (Q âˆ§ (Â¬Qâˆ¨P)) =` <br> `(Â¬Pâˆ§Â¬Q) âˆ¨ (Â¬Pâˆ§P) âˆ¨ (Â¬Qâˆ§Q) âˆ¨ (Pâˆ§Q) =` <br> `(Pâˆ§Q) âˆ¨ (Â¬Pâˆ§Â¬Q)`

---

title: Deduzione logica

- Un *teorema* si riconduce allâ€™implicazione `P â‡’ Q`
    - `P` (*ipotesi*): proposizione che si assume vera
    - `Q` (*tesi*): proposizione di cui si vuole dedurre la veritÃ 
- Processo di *deduzione logica*, o *dimostrazione*, deve seguire ben precisi schemi di ragionamento
    - Dimostrazione diretta (*modus ponens*)
    - Dimostrazione per assurdo (*modus tollens*)

---

title: Dimostrazione diretta

- *Modus ponens*: schema di ragionamento

Premessa | Conseguenza
---------|------------
`(P â‡’ Q)` vera <br> `P` vera | `Q` vera

- Esempio
    - Se c'Ã¨ sole, Ugo arriva in bici (implicazione, *regola d'inferenza*)
    - C'Ã¨ sole (*fatto*)
    - Ugo arriva in bici (*deduzione*)
- **Osservazione**: il solo fatto di sapere che `Pâ‡’Q` Ã¨ vera non consente di concludere niente su `P` e `Q`

---

title: Passaggi intermedi

- Sono possibili dimostrazioni con piÃ¹ passaggi intermedi
- Se vere le implicazioni `Pâ‡’R`, `Râ‡’Q`... <br> e se `P` vera... <br> allora vera anche `Q`
- `((Pâ‡’R) âˆ§ (Râ‡’Q) âˆ§ P) â‡’ Q`
- Schema di ragionamento

 Premessa | Conseguenza
 ---------|------------
 `(P â‡’ R)` vera <br> `(R â‡’ Q)` vera <br> `P` vera | `Q` vera

---

title: Implicazione equivalente

`P` | `Q` | `P â‡’ Q` | `Â¬Q` | `Â¬P` | `Â¬Q â‡’ Â¬P`
----|-----|---------|------|------|----------
 F  |  F  |  T      |  T   |  T   |  T
 F  |  T  |  T      |  F   |  T   |  T
 T  |  F  |  F      |  T   |  F   |  F
 T  |  T  |  T      |  F   |  F   |  T

- Queste due implicazioni sono equivalenti
    - `P â‡’ Q`
    - `Â¬Q â‡’ Â¬P`
- Nelle dimostrazioni, possiamo usare la seconda implicazione al posto della prima

---

title: Dimostrazione per assurdo

- Se Ã¨ vera lâ€™implicazione `(Â¬Q â‡’ Â¬P)` ed Ã¨ vera `P`, allora Ã¨ vera anche `Q`
- *Modus tollens*: schema di ragionamento

 Premessa | Conseguenza
 ---------|------------
 `(Â¬Q â‡’ Â¬P)` vera <br> `P` vera | `Q` vera

- Esempio di teorema
    - `P`: `mÂ·n â‰  0`
    - `Q`: `(m â‰  0) âˆ§ (n â‰  0)`
    - Dimostrazione per assurdo: `Â¬Q â‡’ Â¬P`
    - Se `(m = 0) âˆ¨ (n = 0)`, allora `mÂ·n = 0`

---

title: Logica dei predicati
class: segue dark

---

title: Predicato, o enunciato aperto

- Frase che contiene *variabili*
    - La veritÃ  della frase dipende dal valore delle variabili
    - Se variabili sostituite da valori, diventa proposizione
- Esempio
    - `P(x)`: â€œx Ã¨ un numero dispariâ€
- Occorre definire il *dominio* delle variabili
- *Insieme di veritÃ * del predicato
    - Valori delle variabili che rendono vero l'enunciato
    - Sottoinsieme del dominio delle variabili

---

title: Predicati con connettivi

- `P(x) âˆ§ Q(x)` -- Vero per gli `x` che rendono veri entrambi i pred.
- `P(x) âˆ¨ Q(x)` -- Vero per gli `x` che rendono vero almeno un pred.
- `Â¬P(x)` -- Vero per gli `x` che rendono falso il pred.
- `P(x) â‡’ Q(x)` -- Vero per gli `x` che rendono falso `P` oppure vero `Q`
- `P(x) â‡” Q(x)` -- Vero per gli `x` che rendono i pred. entrambi falsi o entrambi veri

---

title: Quantificatori

- Un predicato puÃ² essere trasformato in una proposizione in due modi
    - Sostituendo la variabili con valori
    - *Quantificando* le sue variabili
    - Una variabile legata ad un quantificatore si dice *vincolata*, altrimenti *libera*
- I quantificatori logici sono due
    - Quantificatore **universale**
    - Quantificatore **esistenziale**

---

title: Quantificatore universale

- Una data proprietÃ  vale per tutti i valori possibili delle variabili
- `âˆ€x, P(x)` -- â€œPer ogni x, P(x) Ã¨ veroâ€
- Esempi
    - `âˆ€n âˆˆ N, n multiplo di 4 â‡’ n pari`
    - `âˆ€x âˆˆ R âˆ€y âˆˆ R, (x + y)^^2^^ = x^^2^^ + 2xy + y^^2^^`

---

title: Quantificatore esistenziale

- Una data proprietÃ  vale per almeno un valore delle variabili
- `âˆƒx : P(x)` -- â€œEsiste almeno un x tale che P(x) Ã¨ veroâ€
- Esempi
    - `âˆƒn âˆˆ N : n pari` -- Esiste almeno un numero pari
    - `âˆƒx âˆˆ R : 2x + 1 = 0` -- L'equazione ammette almeno una soluzione
- Enunciati con `âˆ„` riformulati con `âˆ€` e negando il predicato
    - `âˆ„x : x^^2^^ < 0`
    - `âˆ€x, x^^2^^ â‰¥ 0`

---

title: ProprietÃ  dei quantificatori

- I quantificatori sono sostanzialmente *congiunzioni* o *disgiunzioni* allargate a tutti gli elementi di un insieme
- Due quantificatori dello stesso tipo *possono* essere scambiati di posto senza alterare la veritÃ  dellâ€™enunciato
- Invece, due quantificatori di diverso tipo *non possono* essere scambiati di posto
- I seguenti enunciati sono ben diversi
    - `âˆ€x, âˆƒy : y â‰¥ x`
    - `âˆƒy : âˆ€x, y â‰¥ x`
- **Sillogismi** aristotelici: modus ponens con quantificatori
    - *Premessa maggiore*: â€œTutti gli uomini sono mortaliâ€
    - *Premessa minore*: â€œSocrate Ã¨ un uomoâ€
    - *Conclusione*: â€œSocrate Ã¨ mortaleâ€

---

title: Negazione con quantificatori

- Per negare un enunciato che contiene quantificatori, occorrono due modifiche:
    - **(1)** Sostituire tutti i `âˆ€` con `âˆƒ`, e viceversa
    - **(2)** Negare il predicato
- Esempi
    - `Â¬(âˆ€x, P(x)) â‡” âˆƒx : Â¬P(x)`
    - `Â¬(âˆƒx : P(x)) â‡” âˆ€x, Â¬P(x)`

---

title: Operazioni tra insiemi

- Siano definiti due insiemi: `A = {x : P(x)}, B = {x : Q(x)}`
- Unione: `A âˆª B = {x : x âˆˆ A âˆ¨ x âˆˆ B} = {x : P(x) âˆ¨ Q(x)}`
- Intersezione: `A âˆ© B = {x : x âˆˆ A âˆ§ x âˆˆ B} = {x : P(x) âˆ§ Q(x)}`
- Complemento: `A' = {x : x âˆ‰ A} = {x : Â¬P(x)}`

---

title: ProprietÃ  degli insiemi
class: large-table

- Siano definiti due insiemi: `A = {x : P(x)}, B = {x : Q(x)}`

ProprietÃ  | Op. tra insiemi | Op. tra predicati
----------|-----------------|------------------
Commutativa | `A âˆª B = B âˆª A` | `P âˆ¨ Q â‡” Q âˆ¨ P`
Commutativa | `A âˆ© B = B âˆ© A` | `P âˆ§ Q â‡” Q âˆ§ P`
Associativa | `(AâˆªB) âˆª C = A âˆª (BâˆªC)` | `(Pâˆ¨Q) âˆ¨ R â‡” P âˆ¨ (Qâˆ¨R)`
Associativa | `(Aâˆ©B) âˆ© C = A âˆ© (Bâˆ©C)` | `(Pâˆ§Q) âˆ§ R â‡” P âˆ§ (Qâˆ§R)`
Distributiva | `(AâˆªB) âˆ© C = (Aâˆ©C) âˆª (Bâˆ©C)` | `(Pâˆ¨Q) âˆ§ R â‡” (Pâˆ§R) âˆ¨ (Qâˆ§R)`
Distributiva | `(Aâˆ©B) âˆª C = (AâˆªC) âˆ© (BâˆªC)` | `(Pâˆ§Q) âˆ¨ R â‡” (Pâˆ¨R) âˆ§ (Qâˆ¨R)`
Doppia negazione | `(B')' = B` | `Â¬(Â¬P) â‡” P`
De Morgan | `(A âˆª B)' = A' âˆ© B'` | `Â¬(P âˆ¨ Q) â‡” Â¬P âˆ§ Â¬Q`
De Morgan | `(A âˆ© B)' = A' âˆª B'` | `Â¬(P âˆ§ Q) â‡” Â¬P âˆ¨ Â¬Q`

---

title: Principio di induzione
figure: images/repr/dominoes.png
class: large-figure

- Sia `P(n)` un predicato definito su `â„•`, tale che:
    - **(1)** `P(1)` Ã¨ vero
    - **(2)** `âˆ€n`, supponendo `P(n)` vero, segue che anche `P(n+1)` Ã¨ vero
    - Allora `P(n)` risulta vero `âˆ€n`
- In una formula:
    - `(P(1) âˆ§ (âˆ€n, P(n)â‡’P(n+1)))` <br> `â‡’ (âˆ€n, P(n))`

>

Alcuni predicati sono definiti a partire da un dato `k`, anzichÃ¨ da 1

---

title: Esempio, formula di Gauss

- Definiamo per comoditÃ  `G(n) = nÂ·(n+1) / 2`
- Definiamo il predicato `P(n)` come: `1 + 2 + Â·Â·Â· + n = G(n)`
- Dimostriamo *per induzione* che il predicato Ã¨ vero `âˆ€n`
- **(1)** Il predicato per `n=1` Ã¨ vero, infatti:
    - `G(1) = 1 Â· (1+1) / 2 = 1`
- **(2)** Supponiamo `P(n)` vero, ne segue `P(n+1)` vero, infatti:
    - Per la somma fino ad `n+1`, bisogna aggiungere un termine:
    - `n+1 + G(n) = n+1 + nÂ·(n+1)/2 =` <br> `= (n^^2^^ + 3Â·n + 2) / 2 = (n+1)Â·(n+2)/2 = G(n+1)`
- Quindi la formula vale `âˆ€n`

---

title: ğŸ¤” Operazioni bit a bit in Python
class: break

- Operatori *bitwise*, applicati bit a bit
- Da non confondere con operatori logici (`and`, `or`, `not`)

code: py

    x = 0b1011  # bin value (11 dec)
    y = 0x2A    # hex value (42 dec)

    bin(42)     # '0b101010', a string
    hex(42)     # '0x2a', a string

    x & y       # bitwise AND (applied for each couple of bits)
    x | y       # bitwise OR
    x ^ y       # bitwise XOR
    ~x          # bitwise complement, 0b...11110100

    shift = 3  # some int
    x << shift  # x = x * (2 ** shift)
    y >> shift  # y = y / (2 ** shift)

