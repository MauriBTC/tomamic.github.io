<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Funzioni e oggetti</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="theme/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/oop/balls.png"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Definizione di funzioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/function.png">
        
      </figure><ul>
<li><strong>Funzione</strong>: operatore, applicato a operandi, per ottenere un risultato<ul>
<li><strong><code>func</code></strong> per definire una funzione</li>
<li><strong><code>return</code></strong> per terminare la funzione e restituire un risultato</li>
</ul>
</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>func Hypotenuse(a, b float64) float64 {
    c := math.Sqrt(a*a + b*b)
    return c
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Chiamata di funzioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong><code>func</code></strong> definisce una funzione, ma non la esegue!</li>
<li>Bisogna <em>chiamarla</em></li>
<li>Esecuzione di una f.: nuovo <em>spazio di nomi</em><ul>
<li>Param. e var. hanno <strong>ambito locale</strong></li>
<li>Non visibili nel resto del programma</li>
<li>Nomi uguali, definiti altrove, restano distinti</li>
</ul>
</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>func main() {
    side1 := ToFloat(Prompt("1st leg?"))
    side2 := ToFloat(Prompt("2st leg?"))
    side3 := Hypotenuse(side1, side2)
    Println("3rd side: ", side3)
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Parametri di funzioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Parametri formali</strong>: nomi usati nella <em>definizione</em></li>
<li><strong>Parametri effettivi</strong>: valori passati alla funz.</li>
<li>Parametri passati ‚Äú<em>per copia</em>‚Äù<ul>
<li>Variabili e valori all'esterno: non vengono modificati</li>
<li>(Slice e oggetti passati per puntatore: modifiche <em>permanenti</em>)</li>
</ul>
</li>
<li>Si possono restituire pi√π valori, come <em>tupla</em><ul>
<li><code>return 7, 5, "black"</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Passaggio per copia</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint lang-go" data-lang="go"><code>func Inc(a int) int {
    a += 1
    Println(a)  // just for debug
}

func main() {
    x = 10
    Inc(x)
    Println(x)      // just for debug
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Documentazione di funzioni ‚è©</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Solo le funzioni denominate con la maiuscola sono pubbliche</li>
<li>Altrimenti, usabili solo all'interno dello stesso modulo</li>
<li><em>Docstring</em>: descrizione testuale di una funzione</li>
<li><em><code>go doc</code></em>: comando per visualizzare la documentazione</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>// Return the hypotenuse of a right triangle,
// given both its legs (catheti).
func Hypotenuse(leg1, leg2 float64) float64 {
    return math.Sqrt(leg1*leg1 + leg2*leg2)
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Cicli e annidamento</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/multiplication-table.jpg">
        
      </figure><pre class="prettyprint lang-go" data-lang="go"><code>max := 10
y := 3
for x := 1; x &lt;= max; x++ {
    Println(x * y)
    // Printf("%4d", x * y)
}
</code></pre>
<pre class="prettyprint lang-go" data-lang="go"><code>max := 10
for y := 1; y &lt;= max; y++ {
    for x := 1; x &lt;= max; x++ {
        Printf("%4d", x * y)  // width = 4, no newline
    }
    Println()
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://www.ce.unipr.it/gopherjs/?p2_for_tables.go">http://www.ce.unipr.it/gopherjs/?p2_for_tables.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Scrittura con formattazione ü§î</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong><code>g2d.Printf</code></strong>: <em>scrittura con formattazione</em><ul>
<li>Primo parametro: <em>stringa di formato</em></li>
<li>Segnaposto (<code>%</code>) per incorporare i parametri successivi</li>
<li>Usare <code>\n</code> per andare a capo</li>
</ul>
</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>Printf("%2d", 3)     // " 3", int, width 2
Printf("%6.2f", 7.3) // "  7.30", float, width 6, precision 2
Printf("%d", 'üåê')   // "127760", code
Printf("%c", 'üåê')   // "üåê", char
Printf("%s", "hi!")  // "hi!", string
</code></pre>
<blockquote></blockquote>
<p><a href="https://golang.org/pkg/fmt">https://golang.org/pkg/fmt</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Procedura</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Funzione senza <code>return</code>, solo I/O ed effetti collaterali<ul>
<li><em>Astrazione</em>, per riuso e leggibilit√†</li>
<li>Riduce i livelli di annidamento</li>
</ul>
</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>func printRow(y, size int) {
    for x := 1; x &lt;= size; x++ {
        Printf("%4d", x * y)
    }
    Println()
}
func printTable(size int) {
    for y := 1; y &lt;= size; y++ {
        printRow(y, size)
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Animazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint lang-go" data-lang="go"><code>var image = LoadImage("ball.png")
var x, y, dx = 50, 50, 5
var screen = Size{480, 360}

func tick() {
    //if KeyPressed("Enter") { ... }
    //if x + dx &gt; screen.W { ... }
    ClearCanvas()                  // Draw background
    DrawImage(image, Point{x, y})  // Draw foreground
    x += dx                        // Update ball's position
}
func main() {
    InitCanvas(screen)
    MainLoop(tick)  // Call tick 30 times/second
}
</code></pre>
<p><a href="http://www.ce.unipr.it/gopherjs/?p2_fun_anim.go">http://www.ce.unipr.it/gopherjs/?p2_fun_anim.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Tick, tastiera e mouse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong><code>g2d.MainLoop</code></strong>: <em>ciclo di gestione degli eventi</em><ul>
<li>Parametro opzionale: funzione che sar√† chiamata periodicamente</li>
</ul>
</li>
<li><strong><code>g2d.KeyPressed</code></strong>: <em>controllo se un tasto √® stato premuto</em><ul>
<li>Risultato: <code>bool</code></li>
<li>Parametro: <code>string</code> nome del tasto</li>
<li>Es.: <code>"q", "1", "ArrowLeft", "Enter", "Spacebar", "LeftButton"</code></li>
</ul>
</li>
<li><strong><code>g2d.KeyReleased</code></strong>: <em>controllo se un tasto √® stato rilasciato</em><ul>
<li>Stessi parametri e risultato</li>
</ul>
</li>
<li><strong><code>g2d.MousePosition</code></strong>: <em>posizione del mouse</em><ul>
<li>Risultato: <code>Point</code></li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzione per rimbalzi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/anim-bounce.png">
        
      </figure><ul>
<li>Le funzioni forniscono limitata astrazione<ul>
<li>Incapsulano il comportamento</li>
<li>Ma espongono i dati</li>
</ul>
</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>func moveBall(x, y, dx, dy int) (int, int, int, int) {
    if x + dx &lt; 0 || x + dx + size.W &gt; screen.W {
        dx = -dx
    }
    if y + dy &lt; 0 || y + dy + size.H &gt; screen.H {
        dy = -dy
    }
    return x + dx, y + dy, dx, dy
}
</code></pre>
<p><a href="http://www.ce.unipr.it/gopherjs/?p2_fun_ball.go">http://www.ce.unipr.it/gopherjs/?p2_fun_ball.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Effetti collaterali ü§î</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Operazioni di lettura/scrittura, modifica di variabili globali o oggetti passati per puntatore...</li>
<li>Annullano la <strong>trasparenza referenziale</strong><ul>
<li>Impossibile semplificare, sostituendo una chiamata a funzione col suo valore di ritorno (es. presenti operazioni di I/O)</li>
</ul>
</li>
<li>Rendono la funzione <strong>non idempotente</strong><ul>
<li>Chiamata pi√π volte, con gli stessi parametri, pu√≤ restituire risultati diversi</li>
</ul>
</li>
<li>‚Üí Difficile fare verifiche matematiche<ul>
<li><code>z := f(Sqrt(2), Sqrt(2))</code></li>
<li><code>s := Sqrt(2)</code> <br> <code>z := f(s, s)</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzioni non idempotenti ü§î</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Esempio di semplificazione<ul>
<li><code>p := rq(x) + rq(y) * (rq(x) ‚Äì rq(x))</code></li>
<li><code>p := rq(x) + rq(y) * (0)</code></li>
<li><code>p := rq(x) + 0</code></li>
<li><code>p := rq(x)</code></li>
</ul>
</li>
<li>Ma se <code>rq</code> ha effetti collaterali, non si pu√≤!</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>var baseValue = 0  // global variable

func rq(x int) int {
    baseValue++
    return x + baseValue
}
</code></pre>
<blockquote></blockquote>
<p>Se <code>x, y = 3, 4</code>, ad esempio, i due risultati sono <code>-2</code> e <code>4</code></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Oggetti</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Puntatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/pointer.png">
        
      </figure><ul>
<li>Ogni dato in memoria ha un indirizzo</li>
<li>Variabile puntatore per memorizzarlo</li>
<li><em>Referenziazione</em>: <code>&amp;</code> per indirizzo di un dato</li>
<li><em>Dereferenziazione</em>: <code>*</code> per accesso a dato puntato</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>var i int8 = 56  // one byte
var p *int8      // a ptr to some byte (uninitialized)
p = &amp;i           // now p points to i
*p = *p + 1      // i++
Println(*p, i)
p = nil          // ptr to nothing
</code></pre>
<blockquote></blockquote>
<p>Come in <em>C</em>, ma <em>senza</em> ‚Äúaritmetica‚Äù</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Oggetto</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/basic-object.svg">
        
      </figure><ul>
<li>Rappresenta un <em>oggetto fisico</em> o un <em>concetto</em> del dominio</li>
<li>Memorizza il suo <strong>stato</strong> interno in <em>campi privati</em><ul>
<li><em>Incapsulamento (black box)</em></li>
</ul>
</li>
<li>Offre un insieme di <strong>servizi</strong>, come <em>metodi pubblici</em><ul>
<li>Realizza un <em>tipo di dato astratto (ADT)</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Classi ed oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/cookie-cutter.png">
        
      </figure><ul>
<li>Ogni <em>oggetto</em> ha una <strong>classe</strong> di origine<ul>
<li>La classe d√† la stessa forma iniziale (campi e metodi) a tutti i suoi oggetti</li>
</ul>
</li>
<li>Ma ogni <em>oggetto</em> ha la sua <strong>identit√†</strong><ul>
<li>Stato e locazione in memoria distinti da quelli di altri oggetti</li>
<li>Sia instanze di classi diverse che della stessa classe</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Definizione della classe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/ball-object.svg"><img src="images/oop/ball-uml.svg">
        <figcaption>Class diagram UML</figcaption>
      </figure><ul>
<li><strong>Incapsulamento</strong> dei dati<ul>
<li>Campi in minuscolo: visibilit√† limitata al modulo</li>
<li>Funzione costruttore in maiuscolo: esportata</li>
</ul>
</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>type Ball struct {
    x, y    int
    w, h    int
    dx, dy  int
}

func NewBall(pos Point) *Ball {
    b := &amp;Ball{pos.X, pos.Y, 20, 20, 5, 5}
    return b
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Costruzione oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/bob-builder.jpg">
        
      </figure><ul>
<li><strong><code>NewBall</code></strong>: funzione <em>costruttore</em><ul>
<li>Invocata per creare un oggetto</li>
<li><em>Instantiation is initialization</em></li>
<li>Restituisce un puntatore all'oggetto</li>
</ul>
</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>ball := NewBall(Point{40, 80})  // Allocation and initialization
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Metodi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Espongono <em>servizi</em> ad altri oggetti</li>
<li>Bisogna indicare l'<em>oggetto ricevitore</em>, come puntatore</li>
</ul>
<pre class="prettyprint lang-go" data-lang="go"><code>var arenaW, arenaH = 480, 360

func (b *Ball) Move() {
    if !(0 &lt;= b.x+b.dx &amp;&amp; b.x+b.dx &lt;= arenaW-b.w) {
        b.dx = -b.dx
    }
    if !(0 &lt;= b.y+b.dy &amp;&amp; b.y+b.dy &lt;= arenaH-b.h) {
        b.dy = -b.dy
    }
    b.x += b.dx
    b.y += b.dy
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Applicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint lang-go" data-lang="go"><code>func (b *Ball) Position() Rect {
    return Rect{b.x, b.y, b.w, b.h}
}

func main() {
    b1 := NewBall(Point{40, 80})  // Create two objects,
    b2 := NewBall(Point{80, 40})  // instances of the Ball class

    for i := 0; i &lt; 25; i++ {
        b1.Move()
        b2.Move()
        Println("Ball 1 @", b1.Position())
        Println("Ball 2 @", b2.Position())
    }
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://www.ce.unipr.it/gopherjs/?p2_oop_ball.go">http://www.ce.unipr.it/gopherjs/?p2_oop_ball.go</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Animazione di due palline</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint lang-go" data-lang="go"><code>var b1 = NewBall(Point{40, 80})
var b2 = NewBall(Point{80, 40})

func tick() {
    ClearCanvas()            // BG
    b1.Move()
    b2.Move()
    FillRect(b1.Position())  // FG
    FillRect(b2.Position())  // FG
}

func main() {
    InitCanvas(Size{arenaW, arenaH})
    //SetFrameRate(30)  // default
    MainLoop(tick)
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Variabili locali, parametri, campi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><em>Campi</em>: memorizzano i dati caratteristici di una istanza<ul>
<li>Ogni pallina ha la sua posizione <code>(x, y)</code> e la sua direzione <code>(dx, dy)</code></li>
</ul>
</li>
<li><em>Parametri</em>: passano altri valori ad un metodo<ul>
<li>Se alcuni dati necessari non sono nei campi</li>
</ul>
</li>
<li><em>Variabili locali</em>: memorizzano risultati parziali<ul>
<li>Generati durante l'elaborazione del metodo</li>
<li>Nomi cancellati dopo l'uscita dal metodo</li>
</ul>
</li>
<li><em>Variabili globali</em>: definite fuori da tutte le funzioni<ul>
<li>Usare sono se strettamente necessario</li>
<li>Meglio avere qualche parametro in pi√π, per le funzioni</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercizi</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>2.1 Area di un'ellisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ellipse.svg">
        
      </figure><ul>
<li>Definire una <em>funzione</em> <code>EllipseArea</code> che:<ul>
<li>Riceve come <em>parametri</em> i semiassi di una ellisse: <code>a</code>, <code>b</code></li>
<li>Restituisce come risultato l'area dell'ellisse: <code>œÄ‚ãÖa‚ãÖb</code></li>
</ul>
</li>
<li>Definire una <em>funzione</em> <code>main</code> che:<ul>
<li>Chiede all'utente due valori</li>
<li>Invoca la funzione <code>EllipseArea</code> con questi parametri</li>
<li>Stampa il risultato ottenuto</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.2 Griglia di colori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/color-grid.png"><img src="images/oop/raster-tile.png">
        
      </figure><ul>
<li>Chiedere all'utente dei valori per <code>rows</code> e <code>cols</code></li>
<li>Mostrare una griglia di rettangoli di dimensione <code>rows√ócols</code></li>
<li>Partire da un rettangolo nero in alto a sinistra</li>
<li>In orizzontale, aumentare gradatamente la componente di blu</li>
<li>In verticale, aumentare gradatamente la componente di verde</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a creare una griglia di riquadri tutti neri, con due cicli annidati</p>
<p>Lasciare tra i riquadri un piccolo margine</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.3 Movimento orizzontale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/frogger.png">
        
      </figure><ul>
<li>Mostrare una pallina che si muove in orizzontale<ul>
<li>Variabile <code>dx</code> indica lo spostamento da effettuare ad ogni ciclo</li>
</ul>
</li>
<li>La pallina riappare dal bordo opposto, dopo un po' di tempo<ul>
<li>Permettere alla <code>x</code> della pallina di superare i bordi laterali</li>
<li>Fissare dei margini esterni di <code>100px</code> (p.es.) rispetto ai bordi dell'arena</li>
<li>Se per√≤ la <code>x</code> raggiunge uno dei margini esterni, viene riportata al margine opposto</li>
</ul>
</li>
<li>Alla pressione del tasto <code>Enter</code>, la pallina inverte la direzione</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.4 Movimento per 5 fotogrammi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/frogger.png">
        
      </figure><ul>
<li>Riprendere l'esercizio 2.3</li>
<li>La pallina si muove solo dopo la pressione del tasto <code>Enter</code></li>
<li>Esegue i suoi comportamenti gi√† definiti, ma solo per 5 fotogrammi</li>
<li>Dopo 5 fotogrammi si ferma, in attesa di una nuova pressione del tasto</li>
</ul>
<blockquote></blockquote>
<p>Incrementare (o decrementare) un contatore ad ogni chiamata a <code>tick</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.5 Classe per ellisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ellipse.svg">
        
      </figure><ul>
<li>Classe che modella un'ellisse</li>
<li>Campi privati (parametri del costruttore)<ul>
<li>Semiassi: <code>a, b</code></li>
</ul>
</li>
<li>Metodi pubblici per ottenere...<ul>
<li>Area: <code>œÄ‚ãÖa‚ãÖb</code></li>
<li>Distanza focale: <code>2‚ãÖ‚àö|a<sup>2</sup> - b<sup>2</sup>|</code></li>
</ul>
</li>
<li>Nel corpo principale del programma...<ul>
<li>Creare un oggetto con dati forniti dall'utente</li>
<li>Visualizzare area e distanza focale dell'ellisse</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.6 Animazione di un veicolo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/frogger.png">
        
      </figure><ul>
<li>Partire dalla classe <code>Ball</code> vista a lezione</li>
<li>Eseguire l'animazione<ul>
<li>Per ogni frame, chiamare il metodo <code>move</code> della pallina</li>
<li>Rappresentare un rettangolo nella posizione aggiornata della pallina</li>
</ul>
</li>
<li>Modificare per√≤ il metodo <code>Move</code><ul>
<li>La pallina si sposta sempre di pochi pixel, solo in orizzontale</li>
<li>Se supera 100px oltre il bordo destro, ricompare a 100px prima del bordo sinistro e viceversa</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.7 Pallina con conteggio</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/frogger.png">
        
      </figure><ul>
<li>Partire di nuovo dalla classe <code>Ball</code> vista a lezione</li>
<li>La pallina si muove solo dopo la pressione del tasto <code>Enter</code></li>
<li>Esegue i suoi comportamenti gi√† definiti, ma solo per 5 fotogrammi</li>
<li>Dopo 5 fotogrammi si ferma, in attesa di una nuova pressione del tasto</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.8 Animazione di un alieno</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/science-of-spaceships.jpg">
        
      </figure><ul>
<li>Partire di nuovo dalla classe <code>Ball</code> vista a lezione</li>
<li>Il movimento di base per√≤ √® solo orizzontale</li>
<li>Arrivato al bordo, il personaggio:<ul>
<li>Si sposta di qualche pixel verso il basso</li>
<li>Poi cambia direzione orizzontale</li>
</ul>
</li>
<li>Fare in modo che, in ogni frame, lo spostamento sia solo orizzontale, o solo verticale, ma <em>non</em> diagonale</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.9 Spirale ad oggetti ü§î</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/spiral-circles.png">
        
      </figure><ul>
<li>Mostrare l'<em>animazione</em> di un cerchio lungo una spirale</li>
<li>Realizzare una classe per gestire dati e comportamento del cerchio</li>
<li>Implementare il movimento in un metodo <code>Move()</code></li>
<li>Campi: <code>xc</code>, <code>yc</code>, <code>i</code><ul>
<li><code>i</code> conta i passi; se eccede il limite, torna a 0</li>
</ul>
</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="theme/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://sowide.unipr.it/tomamic">sowide.unipr.it/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>