<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Linguaggio C++11</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="theme/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/dev/cpp.png"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Hello, C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>File sorgente: <code>hello.cpp</code></li>
<li><code>cout</code>: output su console, op. di inserimento <code>&lt;&lt;</code><ul>
<li>Possibile concatenare piÃ¹ operazioni di scrittura</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    cout &lt;&lt; "Hello, C++!" &lt;&lt; endl;
}
</code></pre>
<pre class="prettyprint" data-lang="term"><code>g++ hello.cpp -o hello.exe
</code></pre>
<blockquote></blockquote>
<p>Compilatore: <a href="https://tomamic.github.io/intro.html#11">https://tomamic.github.io/intro.html#11</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Leggere e scrivere</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>cin</code>: input da console, op. di estrazione <code>&gt;&gt;</code><ul>
<li>Possibile concatenare piÃ¹ operazioni di lettura</li>
<li><code>getline(cin, line)</code>: lettura intera riga</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    string name;
    int age;
    cout &lt;&lt; "Name and age?" &lt;&lt; endl;
    cin &gt;&gt; name &gt;&gt; age;
    cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "." &lt;&lt; endl;
    cout &lt;&lt; "You're " &lt;&lt; age &lt;&lt; " years old." &lt;&lt; endl;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Tipizzazione statica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/algo/my-shoes.png">
        
      </figure><ul>
<li>Una delle differenze principali: le comuni variabili non sono <em>riferimenti</em>, ma <em>contenitori</em> di dati<ul>
<li>Occorrono <strong>dichiarazioni</strong> di tipo</li>
<li>Ma possibile <em>type inference</em> (<code>auto</code>)</li>
</ul>
</li>
<li>Tipi principali: <code>int</code>, <code>float</code> e <code>double</code>, <code>bool</code>, <code>string</code> e <code>char</code></li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>int x = 10;
double h = 3.7;
string s = "hello";

auto y = 5;        // type inference
auto k = 2.2;
auto t = "hola"s;  // compiler settings: -std=c++14
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Operazioni di base</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Operazioni su numeri: <code>+, -, *, /, %</code><ul>
<li>Anche incremento e decremento unitario: <code>++, --</code></li>
<li><em>Attenzione</em>: la divisione tra interi dÃ  risultato intero (<code>trunc</code>); il resto puÃ² essere negativo</li>
<li>Assegnamento: <code>=, +=, -=</code> ...</li>
<li>Confronti: <code>&gt;, &gt;=, &lt;, &lt;=, !=, ==</code></li>
<li><em>Attenzione</em>: i confronti <strong>non</strong> si possono concatenare</li>
</ul>
</li>
<li>Operazioni booleane (and, or, not): <code>&amp;&amp;, ||, !</code></li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>cout &lt;&lt; (3 &lt; 5) &lt;&lt; endl;           // 1
cout &lt;&lt; (3 &lt; 5 &lt; 4) &lt;&lt; endl;       // 1 (!)
cout &lt;&lt; (3 &lt; 5 &amp;&amp; 5 &lt; 4) &lt;&lt; endl;  // 0
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Stringhe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>string</code>: sequenza <em>mutevole</em> di byte (tipo <code>char</code>)</li>
<li>Operazioni di confronto; concatenazione: <code>+</code></li>
<li><em>Attenzione</em>: apici doppi per valori <code>string</code>, singoli per <code>char</code></li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>string sentence = "Lorem ipsum";
sentence[6] = 'I';
cout &lt;&lt; sentence[6];  // 'I'

int n = 5;
string txt = to_string(n);
int val = stoi(txt);  // see also `stod`, `stof`...
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Decisioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/algo/words.svg">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>string a, b;
cin &gt;&gt; a &gt;&gt; b;
if (a &lt; b) {
    cout &lt;&lt; "The words are ordered" &lt;&lt; endl;
} else if (a &gt; b) {
    cout &lt;&lt; "The words are inverted" &lt;&lt; endl;
} else {
    cout &lt;&lt; "The words are equal" &lt;&lt; endl;
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p1-algoritmi.html#16">http://tomamic.github.io/p1-algoritmi.html#16</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Iterazioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/algo/average.svg">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>int val, total = 0, count = 0;
cout &lt;&lt; "Val (0 to finish)? ";
cin &gt;&gt; val;
while (val != 0) {
    total += val;
    ++count;
    cout &lt;&lt; "Val (0 to finish)? ";
    cin &gt;&gt; val;
}
if (count &gt; 0) {
    cout &lt;&lt; "Avg: " &lt;&lt; total / float(count) &lt;&lt; endl;
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p1-algoritmi.html#20">http://tomamic.github.io/p1-algoritmi.html#20</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;

double hypotenuse(double a, double b) {
    auto c = sqrt(a * a + b * b);
    return c;
}

int main() {
    auto side1 = 3.0, side2 = 4.0;
    auto side3 = hypotenuse(side1, side2);
    cout &lt;&lt; "3rd side: " &lt;&lt; side3 &lt;&lt; endl;
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p2-oggetti.html#4">http://tomamic.github.io/p2-oggetti.html#4</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Parametri per riferimento ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Parametri passati per riferimento sono <em>alias</em><ul>
<li>Le modifiche riguardano anche le variabili esterne</li>
<li>Limitarne l'uso!</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>// pass by reference: external vars can be modified
void swap(int&amp; m, int&amp; n) {
    int tmp = m;
    m = n; n = tmp;
}

int main() {
    int a = 5, b = 7;
    swap(a, b);
    cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Strutture in g2d</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Composizione di tipi elementari in strutture composte<ul>
<li>Possibile alternativa alle tuple di Python</li>
</ul>
</li>
<li>Le seguenti <code>struct</code> sono definite in <code>g2d/actor.hpp</code></li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>struct Point { int x, y; };
struct Size { int w, h; };
struct Rect { int x, y, w, h; };
struct Color { int r, g, b; };
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Grafica con g2d</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>#include "g2d/canvas.hpp"  // use your path!
auto x = 50, y = 50, dx = 5, dy = 0;
auto image = g2d::load_image("ball.png");

void tick() {
    if (g2d::key_pressed("LeftButton")) { dx = -dx; }
    g2d::clear_canvas();
    g2d::draw_image(image, {x, y});
    x += dx;
}
int main() {
    g2d::init_canvas({480, 360});
    g2d::main_loop(tick);
}
</code></pre>
<pre class="prettyprint" data-lang="term"><code>g++ *.cpp -pthread
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Numeri casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

int main() {
    srand(time(nullptr));           // just once! (initial seed
                                    // for random numbers)
    for (int i = 0; i &lt; 10; ++i) {
        int r = 1 + rand() % 90;    // random value: 1 &lt;= r &lt;= 90
        cout &lt;&lt; r &lt;&lt; endl;
    }
}
</code></pre>
<blockquote></blockquote>
<p>In alternativa (con estremi inclusi): <code>g2d::randint(1, 90)</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Vector, array dinamici</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/shopping-list.jpg">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>#include &lt;vector&gt;
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>vector&lt;string&gt; grocery = {"spam", "egg", "beans"};  // init list
cout &lt;&lt; grocery[1] &lt;&lt; endl;  // egg
cout &lt;&lt; grocery.size() &lt;&lt; endl;  // 3
grocery[0] = "sausage";  // replace an elem

grocery.push_back("bacon");  // add elem to the end
grocery.pop_back();  // remove last elem
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p3-composizione.html#4">http://tomamic.github.io/p3-composizione.html#4</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Cicli for</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>for (auto product : grocery) {  // for each product in grocery
    cout &lt;&lt; product &lt;&lt; endl;
}
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>for (int i = 0; i &lt; 5; ++i) {  // for each i : 0 &lt;= i &lt; 5
    cout &lt;&lt; i * i &lt;&lt; endl;
}
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>int i = 0;
while (i &lt; 5) {  // equivalent while
    cout &lt;&lt; i * i &lt;&lt; endl;
    ++i;
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p3-composizione.html#8">http://tomamic.github.io/p3-composizione.html#8</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Somma colonne: matrice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>vector&lt;vector&lt;int&gt;&gt; matrix = { {2, 4, 3, 8},
                               {9, 3, 2, 7},
                               {5, 6, 9, 1} };
auto rows = matrix.size();
auto cols = matrix[0].size();
for (auto x = 0; x &lt; cols; ++x) {
    auto total = 0;
    for (auto y = 0; y &lt; rows; ++y) {
        total += matrix[y][x];
    }
    cout &lt;&lt; "Col #" &lt;&lt; x &lt;&lt; " sums to " &lt;&lt; total &lt;&lt; endl;
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p5-matrici.html#9">http://tomamic.github.io/p5-matrici.html#9</a></p></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Iteratori ed algoritmi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/iterator.png">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>#include &lt;algorithm&gt;
// count, find, sort etc.
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>// insert at index 1, other elems shift
grocery.insert(grocery.begin() + 1, "bacon");
// remove elem at index 1, other elems shift back
grocery.erase(grocery.begin() + 1);
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>auto pos = find(grocery.begin(), grocery.end(), "egg");
if (pos != grocery.end()) {
    // true, grocery contains "egg"
    grocery.erase(pos);
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p3-composizione.html#4">http://tomamic.github.io/p3-composizione.html#4</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Allocazione di vector</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Metodo <code>assign</code> per allocare una lista o una matrice<ul>
<li><em>Dimensione</em> nota</li>
<li><em>Valore iniziale</em> uguale per tutti gli elementi</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>vector&lt;string&gt; some_list;
some_list.assign(10, ""); // 10 strings
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>vector&lt;vector&lt;char&gt;&gt; some_matrix;
some_matrix.assign(rows, vector&lt;char&gt;(cols, '-'));
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Oggetti</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Creazione ed uso degli oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/balls.png">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>int main() {
    Ball b1{40, 80};
    Ball b2{80, 40};

    for (auto i = 0; i &lt; 25; ++i) {
        b1.move();
        b2.move();
        cout &lt;&lt; b1.get_x() &lt;&lt; ", " &lt;&lt; b1.get_y() &lt;&lt; endl;
        cout &lt;&lt; b2.get_x() &lt;&lt; ", " &lt;&lt; b2.get_y() &lt;&lt; endl &lt;&lt; endl;
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Allocazione dinamica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>Ball b1{40, 80};
Ball* b2 = new Ball{80, 40};
// Ball* alias1 = &amp;b1; // no new ball is created
// Ball* alias2 = b2;  // no new ball is created

for (auto i = 0; i &lt; 25; ++i) {
    b1.move();
    b2-&gt;move();
    cout &lt;&lt; b1.get_x() &lt;&lt; ", " &lt;&lt; b1.get_y() &lt;&lt; endl;
    cout &lt;&lt; b2-&gt;get_x() &lt;&lt; ", " &lt;&lt; b2-&gt;get_y() &lt;&lt; endl &lt;&lt; endl;
}
delete b2;
</code></pre>
<ul>
<li>No <em>garbage collection</em>: a <code>new</code> deve corrispondere <code>delete</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Cppyy: Chiamare C++ da Python</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="term"><code>pip3 install cppyy
</code></pre>
<pre class="prettyprint" data-lang="py"><code>import cppyy
cppyy.include("ball.cpp")
from cppyy.gbl import Ball

b = Ball(150, 200)
for i in range(10):
    b.move()
    print(b.get_x(), b.get_y())
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Puntatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/pointer.png">
        
      </figure><ul>
<li>Ogni dato presente in memoria ha un indirizzo: variabile puntatore per memorizzarlo<ul>
<li>Operatore <code>&amp;</code> per indirizzo di un dato</li>
<li>Op. <code>*</code> per accesso a dato puntato (<em>dereferenziazione</em>)</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>char i = 56;  // a byte
char* p;      // a ptr to some byte (uninitialized)
p = &amp;i;       // now p points to i
*p = *p + 1;  // ++i
p = nullptr;  // ptr to nothing
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="theme/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Livelli di astrazione</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Fattoria parlante</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/animals.png">
        
      </figure><ul>
<li><em>Classe base</em> come <strong>interfaccia astratta</strong></li>
<li>Es. <code>Animal</code>:<ul>
<li>Tutti fanno un verso (<em>interfaccia</em>)</li>
<li>Ognuno lo fa diverso (<em>polimorfismo</em>)</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>class Animal {
public:
    virtual void say() = 0;
};
</code></pre>
<blockquote></blockquote>
<p><a href="https://github.com/tomamic/fondinfo/blob/master/cpp/animals/main.cpp">https://github.com/tomamic/fondinfo/blob/master/cpp/animals/main.cpp</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Classi concrete</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/polymorphism.png">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>class Dog : public Animal {
    string name_;
public:
    Dog(string name) { name_ = name; }
    void say() {
        cout &lt;&lt; "I am " &lt;&lt; name_ &lt;&lt; " Dog. "
             &lt;&lt; "I say: WOOF!" &lt;&lt; endl;
    }
};
class Cat : public Animal {
    /* ... */
    void say() {
        cout &lt;&lt; "I am " &lt;&lt; name_ &lt;&lt; " Cat. "
             &lt;&lt; "I say: MEOW!" &lt;&lt; endl;
    }
};
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lista di puntatori ad oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/peppa.png">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>auto d = new Dog("Danny");
auto c = new Cat("Candy");
auto p1 = new Pig("Peppa");
auto p2 = new Pig("George");
// Polimorphism requires pointers to objects.
// Elements can be added with push_back, too.
vector&lt;Animal*&gt; animals = {d, c, p1, p2};
for (auto a : animals) { a-&gt;say(); }
</code></pre>
<pre class="prettyprint" data-lang="output"><code>I am Danny Dog. I say: WOOF!
I am Candy Cat. I say: MEOW!
I am Peppa Pig. I say: OINK!
I am George Pig. I say: OINK!
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Metodi virtuali puri</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/actor.svg">
        
      </figure><ul>
<li>Es.: metodo <code>move</code> di <code>Actor</code><ul>
<li><code>virtual</code>: il metodo puÃ² essere ridefinito nelle sottoclassi (<em>polimorfo</em>)</li>
<li><code>= 0</code>: il metodo non Ã¨ implementato qui (la classe Ã¨ <em>astratta</em>)</li>
<li>Polimorfismo C++ funziona solo con puntatori a oggetti</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>class Actor {
    virtual void move() = 0;
    // ...
};
</code></pre>
<blockquote></blockquote>
<p><a href="https://github.com/tomamic/fondinfo/blob/master/cpp/bounce/actor.h">https://github.com/tomamic/fondinfo/blob/master/cpp/bounce/actor.h</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fifteen â€“ Gioco astratto</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/fifteen-puzzle.jpg">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>class BoardGame {
public:
    virtual void play_at(int x, int y) = 0;
    virtual void flag_at(int x, int y) = 0;
    virtual int cols() = 0;
    virtual int rows() = 0;
    virtual string get_val(int x, int y) = 0;
    virtual bool finished() = 0;
    virtual string message() = 0;

    virtual ~BoardGame() {}
};
</code></pre>
<blockquote></blockquote>
<p><a href="https://github.com/tomamic/fondinfo/blob/master/cpp/boardgames/boardgame.h">https://github.com/tomamic/fondinfo/blob/master/cpp/boardgames/boardgame.h</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Gioco a console</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>void print_game(BoardGame* game) {
    for (auto y = 0; y &lt; game-&gt;rows(); ++y) {
        for (auto x = 0; x &lt; game-&gt;cols(); ++x) {
            cout &lt;&lt; setw(3) &lt;&lt; game-&gt;get_val(x, y);
        }
        cout &lt;&lt; endl;
    }
}
void play_game(BoardGame* game) {
    print_game(game);
    while (! game-&gt;finished()) {
        int x, y; cin &gt;&gt; x &gt;&gt; y;
        game-&gt;play_at(x, y);
        print_game(game);
    }
    cout &lt;&lt; game-&gt;message() &lt;&lt; endl;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Compilazione separata ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>C++: definizione della classe separata dalla implementazione dei metodi<ul>
<li>Definizione fornita agli utenti</li>
<li>Implementazione compilata in libreria</li>
</ul>
</li>
<li>Sorgenti organizzati in 3 file:<ul>
<li><code>ball.h</code> â€“ definizione della classe</li>
<li><code>ball.cpp</code> â€“ implementazione dei metodi</li>
<li><code>main.cpp</code> â€“ applicazione che usa la classe</li>
<li>Dall'ambiente di sviluppo: <em>Add new â†’ C++ Class</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Definizione: ball.h ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/ball-object.svg"><img src="images/oop/ball-uml.svg">
        <figcaption>Class diagram UML</figcaption>
      </figure><pre class="prettyprint" data-lang="c++"><code>class Ball {
public:
    Ball(int x0, int y0);
    void move();
    int get_x();
    int get_y();

    static const int ARENA_W = 320, ARENA_H = 240;
    static const int W = 20, H = 20;

private:
    int x_;
    int y_;
    int dx_ = 5;
    int dy_ = 5;
};
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Implementazione: ball.cpp ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/anim-bounce.png">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>#include "ball.h"

Ball::Ball(int x0, int y0) {
    x_ = x0; y_ = y0;
}
void Ball::move() {
    if (x_ + dx_ &lt; 0 || x_ + dx_ + W &gt; ARENA_W) dx_ = -dx_;
    if (y_ + dy_ &lt; 0 || y_ + dy_ + H &gt; ARENA_H) dy_ = -dy_;
    x_ += dx_; y_ += dy_;
}
int Ball::get_x() {
    return x_;
}
int Ball::get_y() {
    return y_;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Applicazione: main.cpp ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/balls.png">
        
      </figure><pre class="prettyprint" data-lang="c++"><code>#include "ball.h"
// ...
int main() {
    Ball b1{40, 80};
    Ball b2{80, 40};

    for (auto i = 0; i &lt; 25; ++i) {
        b1.move();
        b2.move();
        cout &lt;&lt; b1.get_x() &lt;&lt; ", " &lt;&lt; b1.get_y() &lt;&lt; endl;
        cout &lt;&lt; b2.get_x() &lt;&lt; ", " &lt;&lt; b2.get_y() &lt;&lt; endl &lt;&lt; endl;
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Swig: C++ per moduli Python ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="file: ball.i"><code>%module ball
%include "std_string.i"
%{
#include "ball.h"  /* Include the header in the wrapper code */
%}
%include "ball.h"  /* Parse the header to generate wrappers */
</code></pre>
<pre class="prettyprint" data-lang="term"><code>swig -python -c++ ball.i
g++ -fPIC -shared *.cpp *.cxx -I/usr/include/python3.6m -o _$module.so
</code></pre>
<pre class="prettyprint" data-lang="py"><code>from ball import Ball
b = Ball(150, 200)
for i in range(10):
    b.move()
    print(b.get_x(), b.get_y())
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Output su file ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>#include &lt;fstream&gt;
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>int n; float r; string w;
cin &gt;&gt; n &gt;&gt; r &gt;&gt; w;

ofstream file2{"output.txt"};  // file output stream
if (file2) {                   // is stream available?
    file2 &lt;&lt; "Values: " &lt;&lt; n &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; w &lt;&lt; endl;
}
file2.close();
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lettura di righe ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>ifstream file1{"input.txt"};  // when finished, close file1!
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>string first_line, second_line;
getline(file1, first_line);   // no newline at end
getline(file1, second_line);  // no newline at end
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>string whole_text;
getline(file1, whole_text, '\0');  // read whole file
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>// for each line in file1...
for (string line; getline(file1, line);) {
    cout &lt;&lt; line &lt;&lt; endl;
}
</code></pre>
<blockquote></blockquote>
<p><a href="http://tomamic.github.io/p5-matrici.html#4">http://tomamic.github.io/p5-matrici.html#4</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Flussi e stringhe ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Si puÃ² gestire una stringa come uno stream<ul>
<li><code>istringstream</code>, <code>ostringstream</code> in libreria <code>&lt;sstream&gt;</code></li>
<li>Per estrarre valori ed inserire valori, rispettivamente</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>/* Split a text into a sequence of strings */
string text = "one:two::three";
istringstream sstr{text};  // a stream view on a string
for (string item; getline(sstr, item, ':');) {
    cout &lt;&lt; "- " &lt;&lt; item &lt;&lt; endl;
}
</code></pre>
<pre class="prettyprint" data-lang="output"><code>- one
- two
-
- three
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lettura di dati ðŸ¤”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>ifstream file1{"input.txt"};
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>if (file1) {                         // is stream available?
    int n; float r; string w;
    file1 &gt;&gt; n &gt;&gt; r &gt;&gt; w;
}
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>for (int val; file1 &gt;&gt; val;) {       // or float, string ...
    cout &lt;&lt; setw(4) &lt;&lt; val &lt;&lt; endl;  // val occupies 4 chars
}                                    // setw in &lt;iomanip&gt;
</code></pre>
<pre class="prettyprint" data-lang="c++"><code>file1 &gt;&gt; noskipws;                   // scan also whitespaces
for (char val; file1 &gt;&gt; val;) {      // for each char in file1
    cout &lt;&lt; val &lt;&lt; endl;
}
</code></pre></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="theme/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://sowide.unipr.it/tomamic">sowide.unipr.it/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>